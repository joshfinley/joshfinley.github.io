+++
title = "Red Teamer'&apos;'s Guide to Malware Development 1"
date = 2024-05-16T11:39:01-05:00
draft = true
+++

> Disclaimer: This article is for educational purposes only. And it is not advice.

This is a guide for malware development. Nowadays, there are lots of paid courses that cover these same concepts, but fortunately for everyone, these not necessary to get up to speed. Most of the techniques these courses cover are open source.

This is the first entry in a series that will cover everything needed to get up to speed for more advanced studies in malware development. This is a field that is both deep and broad. Important concepts in malware development involve topics in operating system architecture, low level programming, binary exploitation, and reverse engineering. Malware development is a very intense subject once you get past the intermediate level.

This course will focus on Windows X86_64 malware.

The following topics will be covered in this entry:

1. Introduction to malware
2. Operating system basics
3. Diving into the structure of a process

## Introduction to Malware

Malware is software that does something bad. You usually want software to be useful, like assist you in writing emails or documents, do your taxes, or relax with a video game. Malware isn't helpful or beneficial. It might pretend to be something that is, but malware is essentially software that might:

- Steal your private data
- Farm your system resources for profit
- Harm your business 
- Enable fraud, scams, or even just annoying advertising

There are different names for different types of malware (spyware, trojans, viruses, etc.). These have sometimes overlapping definitions, so we don't need to really bother with them here.

In our context as red teamers and penetration testers, malware enables us achieve our goals in finding flaws in our customer's organizations. An example is a post-exploitation implant, which we execute on a victim host in order to pilfer the filesystem, expand our access to other systems, or demonstrate compromise. 

Additionally, there are programs we consider "attack tools" which may facilitate specific types of attacks. One example could be [Mimikatz](https://github.com/gentilkiwi/mimikatz), a fully featured tool for Windows authentication attacks. We might deploy attack tools from an implant or run them independently. Attack tools and implants will be the focal point of this series.

### Functions of an Implant

An implant will usually have one or more of the following capabilities:

- Information gathering (network, processes, files)
- Run additional code on the target
- Execute shell commands
- Communication with attacker controlled servers (command and control or C2)
- (sometimes) Evasion techniques

###  Functions of an Attack Tool

An attack tool enables us to achieve our goals in an assessment. Examples include tools which:

- Allow us to use or attack certain services (E.g., [evil-winrm](https://github.com/Hackplayers/evil-winrm))
- Access credentials and authentication material (E.g., [Mimikatz](https://github.com/gentilkiwi/mimikatz))
- Escalate privileges (E.g., [SharpUp](https://github.com/GhostPack/SharpUp?tab=readme-ov-file))
- Attack authentication protocols / perform MITM attacks(e.g., [ntlmrelayx](https://github.com/fortra/impacket/blob/master/examples/ntlmrelayx.py))
- And much more.

Some attack tools we can run from our own machines, others we will need to execute on our victims.

## Operating Systems Basics

To write high quality, evasive malware you need to have three ingredients:

1. A purpose
2. Coding skills
3. Operating systems knowledge

**Purpose**

What is the point of the malware? Is it an implant? Is it an attack tool? What is it supposed to enable us to achieve?

**Coding Skills**

We need to be able to write code in the necessary language and understand how it works as much as we can. This is especially important if you have to evade security tools. Copy and pasting other people's code will only get you so far, and carries greater risk - if you don't know how your off-the-shelf precompiled attack tool works, how can you be sure there is not a backdoor in it that will get YOU breached?

**Operating Systems Knowledge**

Doing useful things means at least knowing what the operating system makes available to us. It is our broker and enabler, but it can also facilitate defense tools catching us. If we hope to evade defenses, we need to know how they work, meaning how they leverage the operating system to detect and destroy our malware.

### The Purpose of the Operating System

Fun fact: you can use a computer without an operating system. Its probably not particularly enjoyable or efficient, though. The operating system serves three main purposes, which are closely interrelated:

- Abstraction: Most of us really don't want to think about machine language, circuits, physical memory, and physical storage device internals when we use our computers. We want this *simplified* away for us. We wan't the drive represented as just a drive and its use as simple as dragging and dropping. Abstracction of these messy details is the most important concept.

- Ease of use: Abstraction leads into ease of use. I can guarantee you nobody wants to manually desingate the cylinder, track, sector, and block of the location we want to store a cat picture. We want to just put it on a specific drive and have the rest figured out for us. We also don't want to write the code that tells the hardware how to do it. We want a driver (that someone else wrote) to just do it for us
  
- Stability: When we do something like move folder containing precious family pictures, we don't want the operating system to crash and destroy our data. We want the system to be fault tolerant, able to recover from errors, and present a seamless user experience.

The operating system aims to achieve all of these goals.

### User Mode Versus Kernel Mode

The below diagram might be messy, but it provides a reasonable overview of the Windows OS. For now, we can ignore most of the white boxes inside the grey "Executive" block, as well as the "integral subsystems", "environment subsystems", "microkernel" and "hardware abstraction layer".

Instead, we will turn our focus to the three big chunks: User mode, kernel mode, and hardware.

![Credit to Wikipedia for this diagram](vscode-local:/c%253A/Users/finle/AppData/Local/Temp/Windows_2000_architecture.svg)

User mode is where all our day-to-day applications and processes live. Microsoft Word, Slack Desktop, the Command Prompt, all of these are user mode processes. The kernel mode is where the operating system and device drivers live.

### User Mode Abstraction

What does abstraction mean in this context? For the most part, it really just means hiding details. For example, modern computers can run multiple (dozens, hundreds) of processes at once. Each process needs its own threads to execute in and a region of memory to store code and data. But there might be dozens or even hundreds of processes all running at the same time. How does a process ensure it doesn't overwrite memory used by another process? How does it ensure it doesn't just takeover a thread of another process? 

The answer is, it doesn't. Processes (in user mode) are gleefully unaware of the nasty details of how they run. To the process, it has access to the full system memory, and it is the only executor of threads. It need not check to see if another process is using threads or memory, because its the only one it is aware of! Obviously, this is an illusion. Other processes are running, and probably even using the same physical hardware threads for executing code. But the operating system hides all this, and presents a neat, tidy, isolated execution space for each user mode process. The spaghetti underneath is *abstracted* away, hidden from view. In addition, changes in CPU design have enabled this seperation with operating modes, specifically real mode vs. protected mode. Access to memory is restricted at the hardware level, in addition to being physical memory being abstracted away by the operating system.

This also provides a security barrier. Because the process only has access to a mostly blank chunk of memory, it can't see memory for other proccesses without being deliberately granted that access by the operating system. In many cases, the operating system just does not allow certain things to be accessed by user mode processes. This wasn't always the case. Back in the days of Microsoft DOS, everything, including user processes ran at the same privilege level. The kernel (core of the DOS operating system) still provided useful abstractions, but did nothing to provide essential isolation features, or to protect itself from modification. This meant that processes had access to all memory and hardware. A piece of malware could essentially do anything it wanted.

### Hexadecimal

Before we continue, it is essential to understand and not be afraid of hexadecimal. In computers, just about every memory address and value we will see will often be represented in hex. Hexadecimal makes it easier to represent and work with binary numbers. It is a notation that was chosen specifically based on how we organize binary data in computers. Since the smallest addressable unit of memory is the byte (eight bits), each byte can be represented by two hexadecimal digits. The numberline for hexadecimal runs through the (decimal) number 15. Including zero, a single hexadecimal digit can represent 16 possible values. The hex numberline looks like this:

```
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
```

Counting by eights is easier in hexadecimal because the base-16 system allows us to quickly see patterns and transitions. Here's a demonstration of counting by eights in both decimal and hexadecimal:

**Decimal:**
```
0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128
```

**Hexadecimal:**
```
0x0, 0x8, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38, 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x
```

Every transition happens at 0x8 and 0x10, 0x18 and 0x20, making it easier to recognize and follow the increments. Memory on a computer is grouped with the smallest unit being the byte, which is represented by two hex digits. Memory locations (where data can be stored and accessed quickly) are labeled with addresses. These addresses are always represented in hex because the unit of data in use is the byte. Comparing addresses in hexadecimal notation vs decimal notation makes the utlity of hex much more obvious:

Hexadecimal:
```
0x7FFFFA0000, 0x7FFFFA0008, 0x7FFFFA0010, 0x7FFFFA0018, 0x7FFFFA0020
```

Decimal:
```
140737467146240, 140737467146248, 140737467146256, 140737467146264, 140737467146272
```

Its clear that the hex representation is much easier to read. Not only is it shorter, but the increments of data are more plainly visible.

### Virtual Memory

I've touched on virtual memory several times now, but the concept is so important it deserves its own section. An important question here is "why is it called virtual?"

This is to distinguish this memory from physical memory. It is essentially simulated. Sure, the real bytes sit in real RAM somewhere, involving real matter and electrical charges, but the way this is represented to the process is an illusion. The process sees an available region of memory locations, each with an address.  As mentioned before, these addresses are labels for a data storage location and are represented in *hexadecimal* notation. 

The process just sees a large chunk of contiguous memory that it can use as it needs. In gritty reality, the actual physical location on the stick of RAM could be anywhere. The operating system maintains a complex mapping of all available physical memory and will pick and choose where to put the data. This means while the chunk of memory looks contiguous to the process, each location might be non-sequential on the stick of RAM. 

```
+-----------------------+        +-----------------------+
|   Virtual Memory      |        |    Physical Memory    |
+-----------------------+        +-----------------------+
| Address    | Value    |        | Address    | Value    |
+------------|----------+        +------------|----------+
| 0x00000000 | 0x1A2B3C |------->| 0x0FFA1C6A | 0x1A2B3C |
+------------|----------+        +-----------------------+
| 0x00000004 | 0x2B3C4D |----+   | ...                   |
+------------|----------+    |   +-----------------------+
| 0x00000008 | 0x3C4D5E |-+  +-->| 0x1FFC734F | 0x2B3C4D |
+------------|----------+ |      +-----------------------+
                          |      |...                    |
                          |      +-----------------------+
                          +----->| 0x2FFD732A | 0x2B3C4D |
                                 +-----------------------+
```

## The Structure of a Process

In general, a process needs two things: a means to execute code, and memory.

In practice, this manifests as:

- Threads (for execution)
- Heap, stack, mapped, and reserved memory (for data storage)

Each thread has its own *stack*. Each stack is a region of memory the thread uses to store things like variables and arguments to functions. The thread interacts directly with the stack very frequently during execution. The stack is usally fixed in size, although its size can be modified. Data stored in the stack is usally smaller.

The *heap* may or may not by an application, but on Windows, each process has a built-in heap. The heap allows for a more dynamic and persistent storage location. The heap is often used for larger allocations, such as in the case of buffering an image.

The process also may have memory not associated with a stack or heap. Every windows process will have some blocks of *mapped* memory, which usually contains metadata about the process and its dependencies. The process may also request *reserved* memory from the operating system, which is usable for holding data but is not considered a stack or a heap and may be used in a somewhat free-flowing manner.

### Code: Data vs Execution

The code (instructions to execute) of a process is also stored in memory. The *thread* will run through the instructions in this region and execute them. The thread runs instructions for the CPU. These are operations like addition, subtraction, multiplication, as well as logical operations (decisions), and memory manipulation operations. 

Each thread has an *execution context*. In addition to virtual memory, an executing thread has access to a set of *registers* that store data. These registers are also places where we can store memory, but registers are even more fast and convenient for the thread to use than RAM. The caveat is much less data can be stored in registers than in memory.

Our program code is always translated at some point to machine code that the processor can understand. The operating system keeps track of our processes thread, stacks, heaps, reserved memory, mapped memory, and registers.


### Thread Context

The threads execution context is the combination of the registers (very quickly accessible but small units of memory).

The x86_64 thread context looks something like this (with a few simplifying omissions):

```
+------------------------------------+
|           Thread Context           |
+------------------------------------+
| Control Registers                  |
|------------------------------------|
| RIP (Instruction Pointer)          |
| RSP (Stack Pointer)                |
| RFLAGS (Flags Register)            |
+------------------------------------+
| General Purpose Registers          |
|------------------------------------|
| RAX                                |
| RBX                                |
| RCX                                |
| RDX                                |
| RSI                                |
| RDI                                |
| RBP                                |
| R8                                 |
| R9                                 |
| R10                                |
| R11                                |
| R12                                |
| R13                                |
| R14                                |
| R15                                |
+------------------------------------+
| Segment Registers                  |
|------------------------------------|
| CS (Code Segment)                  |
| DS (Data Segment)                  |
| ES (Extra Segment)                 |
| FS (FS Segment)                    |
| GS (GS Segment)                    |
| SS (Stack Segment)                 |
+------------------------------------+
| Debug Registers                    |
|------------------------------------|
| DR0                                |
| DR1                                |
| DR2                                |
| DR3                                |
| DR6                                |
| DR7                                |
+------------------------------------+
| Floating Point and Vector Registers|
|------------------------------------|
| XMM0                               |
| XMM1                               |
| XMM2                               |
| XMM3                               |
| XMM4                               |
| XMM5                               |
| XMM6                               |
| XMM7                               |
| XMM8                               |
| XMM9                               |
| XMM10                              |
| XMM11                              |
| XMM12                              |
| XMM13                              |
| XMM14                              |
| XMM15                              |
+------------------------------------+
| Miscellaneous State                |
|------------------------------------|
| MXCSR (Control/Status Register)    |
| FPU Control Word                   |
| FPU Status Word                    |
| FPU Tag Word                       |
| FPU Instruction Pointer            |
| FPU Data Pointer                   |
| FPU Opcode                         |
+------------------------------------+
```

Segment, debug, floating point, vector, and miscellaneous state registers can be ignored for now. Instead, focus on the control registers and general purpose registers. Each register has a specific purpose, outlined below:

**Control Registers**

- RIP (Instruction Pointer): Holds the memory address of the next instruction to be executed
- RSP (Stack Pointer): Points to the top of the current stack (memory)
- RFLAGS (Flags Register): Status flags, control flags, and system flags. These flags are important as they can be set by certain CPU instructions (such as comparion operations) and result in the change of RIP to different locations (as one example).

**General Purpose Registers**

- RAX: Accumulator register, used for arithmetic operations and to store function return values.
- RBX: Base register, often used to store addresses of data.
- RCX: Count register, used for loop counters and string operations.
- RDX: Data register, used in I/O operations and to hold function arguments.
- RSI (Source Index): Source index for string operations, points to source data in memory.
- RDI (Destination Index): Destination index for string operations, points to destination data in memory.
- RBP (Base Pointer): Base pointer for the current stack frame, used to reference local variables.
- R8 - R15: Additional general-purpose registers available in x64 architecture, used for extended function arguments and calculations.

Note that these general purpose registers are freely modifiable by CPU instructions. What is most important to understand is the operating systems *conventions* for interacting with these registers. It will look different on different systems. How each register is supposed to be used is defined by the platforms ABI or Application Binary Interface. The ABI specifies which registers are used for which purposes, and rules for preservation of the values in the registers between function calls. We'll talk about this more later.

A given execution state of a thread in a process will look something like this:

```
+-----------------------------------+       +-----------------------------------+
|            Code Segment           |       |                CPU                |
+-----------------------------------+       +-----------------------------------+
| 0x00400000: mov rax, 1            |       | Registers:                        |
| 0x00400005: add rax, rbx          |       | +-------------------------------+ |
| 0x00400008: cmp rax, rcx          |       | | RIP    (Instruction Pointer)  | |
| 0x0040000B: je  0x00400015        |       | | +---------------------------+ | |
| 0x0040000D: sub rax, 2            |       | | | 0x00400005 (add rax, rbx) | | |
| 0x00400010: jmp 0x00400020        |       | | +---------------------------+ | |
| 0x00400015: xor rax, rax          |       | |                               | |
| 0x00400018: ret                   |       | +-------------------------------+ |
| 0x00400020: inc rax               |       | | General Purpose Registers     | |
| 0x00400022: ret                   |       | | +---------------------------+ | |
|                                   |       | | | RAX: 0x01                 | | |
|                                   |       | | | RBX: ???                  | | |
|                                   |       | | | RCD-R15: ???              | | |
|                                   |       | | +---------------------------+ | |
|                                   |       | |                               | |
|                                   |       | | RSP (Stack Pointer)           | |
|                                   |       | | +---------------------------+ | |
|                                   |       | | | Value: ...                | | |
|                                   |       | | +---------------------------+ | |
|                                   |       | |                               | |
|                                   |       | | RBP (Base Pointer)            | |
|                                   |       | | +---------------------------+ | |
|                                   |       | | | Value: ...                | | |
|                                   |       | | +---------------------------+ | |
|                                   |       | |                               | |
|                                   |       | +-------------------------------+ |
|                                   |       | | RFLAGS (Flags Register)       | |
|                                   |       | | +---------------------------+ | |
|                                   |       | | | Value: ...                | | |
|                                   |       | | +---------------------------+ | |
|                                   |       | +-------------------------------+ |
+-----------------------------------+       +-----------------------------------+
```

## Whats running on your Windows system

We've talked generally about the high level building blocks of a Windows system. But what does it look like in reality?

You can quickly get all processes and drivers with the following commands:

```
tasklist
driveryquery /v
```

The utility `procexp` is also useful, for a more graphical representation.

On a system with no additional user applications running, you can expect a process list like the following:

```
Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0          8 K
System                           4 Services                   0         24 K
Registry                       140 Services                   0     31,224 K
smss.exe                       464 Services                   0        420 K
csrss.exe                      556 Services                   0      2,560 K
wininit.exe                    632 Services                   0      2,048 K
csrss.exe                      640 Console                    1      3,400 K
winlogon.exe                   736 Console                    1      5,732 K
services.exe                   776 Services                   0      8,112 K
lsass.exe                      800 Services                   0     14,704 K
svchost.exe                    916 Services                   0     19,372 K
fontdrvhost.exe                944 Services                   0      1,084 K
fontdrvhost.exe                812 Console                    1      1,992 K
dwm.exe                       1040 Console                    1    151,324 K
svchost.exe                   1556 Services                   0      7,380 K
svchost.exe                  10564 Services                   0     16,808 K
svchost.exe                   5940 Services                   0      8,132 K
svchost.exe                   3932 Services                   0     17,096 K
svchost.exe                   4540 Services                   0      5,968 K
Memory Compression            2068 Services                   0     39,204 K
spoolsv.exe                   3176 Services                   0      7,152 K
blnsvr.exe                    3384 Services                   0      2,472 K
IpOverUsbSvc.exe              3440 Services                   0      5,028 K
VGAuthService.exe             3544 Services                   0      2,604 K
MsMpEng.exe                   3656 Services                   0    410,744 K
com.docker.service            2348 Services                   0     22,096 K
WmiPrvSE.exe                  4552 Services                   0     19,080 K
dllhost.exe                   4672 Services                   0      4,904 K
msdtc.exe                     5028 Services                   0      2,564 K
SearchIndexer.exe             4520 Services                   0     52,004 K
dllhost.exe                   5444 Services                   0      4,268 K
AggregatorHost.exe            5672 Services                   0      5,684 K
MpDefenderCoreService.exe     5788 Services                   0     14,064 K
NisSrv.exe                    2672 Services                   0      6,372 K
sihost.exe                    4428 Console                    1     18,804 K
taskhostw.exe                 2004 Console                    1     10,336 K
ctfmon.exe                    2008 Console                    1     14,280 K
explorer.exe                  4324 Console                    1    129,040 K
dllhost.exe                   4980 Console                    1      9,812 K
StartMenuExperienceHost.e     7976 Console                    1     69,420 K
RuntimeBroker.exe             7980 Console                    1     21,216 K
SearchApp.exe                 8284 Console                    1    187,452 K
RuntimeBroker.exe             8364 Console                    1     30,556 K
UserOOBEBroker.exe            8672 Console                    1      5,044 K
RuntimeBroker.exe            10196 Console                    1      5,064 K
SgrmBroker.exe                1052 Services                   0      5,100 K
PhoneExperienceHost.exe       7832 Console                    1     58,336 K
RuntimeBroker.exe             8536 Console                    1      3,640 K
SecurityHealthSystray.exe     9416 Console                    1      4,100 K
SecurityHealthService.exe     7680 Services                   0      8,984 K
OneDrive.exe                 11108 Console                    1     56,308 K
SystemSettings.exe            9556 Console                    1        244 K
ApplicationFrameHost.exe      2376 Console                    1     10,156 K
MusNotifyIcon.exe             7244 Console                    1      2,152 K
msedge.exe                    5360 Console                    1    100,716 K
msedge.exe                   10568 Console                    1      7,556 K
msedge.exe                    1676 Console                    1     25,240 K
msedge.exe                    7468 Console                    1     28,788 K
msedge.exe                    4476 Console                    1     17,348 K
MoUsoCoreWorker.exe           7252 Services                   0     18,524 K
taskhostw.exe                 5696 Console                    1      7,636 K
TrustedInstaller.exe          7864 Services                   0      8,024 K
TiWorker.exe                  9540 Services                   0     11,316 K
LockApp.exe                   9012 Console                    1     51,240 K
RuntimeBroker.exe             9836 Console                    1     38,332 K
TextInputHost.exe             4280 Console                    1     44,616 K
BackgroundTransferHost.ex     2108 Console                    1     22,960 K
WindowsTerminal.exe           5340 Console                    1     86,920 K
OpenConsole.exe               6864 Console                    1      8,820 K
powershell.exe                9700 Console                    1     74,616 K
RuntimeBroker.exe             5248 Console                    1     12,964 K
tasklist.exe                  6768 Console                    1      9,200 K
```

The following sections delve into the most important processes listed above.

### System

The System process, also known as the kernel process, is responsible for handling system-level operations and kernel-mode drivers. It is a critical part of the operating system that manages low-level tasks and hardware interactions.

### Registry

This process is responsible for managing the Windows registry, a database that stores low-level settings and configurations for the operating system and applications. It handles reading and writing registry data.

### Services.exe

The Service Control Manager (services.exe) manages the starting, stopping, and interaction of system services. It ensures that all required services are running and handles their dependencies. It also handles service configuration, monitoring, dependencies, and communication.

### Svchost.exe

Notice that there are multiple instances of something called `svchost.exe` running. Why is this?

`svchost.exe` stands for Service Host, and is an integral OS component. Services on windows are background processes which perform various functions. So each `svchost.exe` process will correspond to unique services. Services are grouped and organized based on various parameters, and each group gets its own process {{< reference content="https://learn.microsoft.com/en-us/windows/application-management/svchost-service-refactoring" >}}.

You can fetch the associated service of a `svchost.exe` process with `tasklist /svc /fi "imagename eq svchost.exe"`.

### Lsass.exe

`lsass.exe` might be the most abused process in all of Windows. This is because it is the usermode process that handles all of the authenticationon the system. However, not only is it responsible for performing the authentication, it will also *hold onto* authentication material, like Kerberos tickets, for their lifetime. `lsass.exe` is started during Windows initialization. When you try to logon to the computer, the `winlogon.exe` process relays your login credentials to `lsass.exe` to make the decision on whether to log you in. `lsass.exe` will validate against stored data, either locally or on a server. If everything checks out, it will generate a *security token* for use during your session. 

#### Security Tokens

The security token contains a plethora of data about your user and what it can do. The below shows an example of the data that might be contained in a security token:

```
Security Token:
- User SID: S-1-5-21-3623811015-3361044348-30300820-1013
- Group SIDs:
  - S-1-5-32-544 (Administrators)
  - S-1-5-32-545 (Users)
  - S-1-5-32-546 (Guests)
  - S-1-5-18 (Local System)
  - ...
- Privileges:
  - SeShutdownPrivilege
  - SeChangeNotifyPrivilege
  - SeUndockPrivilege
  - SeIncreaseWorkingSetPrivilege
  - SeTimeZonePrivilege
  - ...
- Owner SID: S-1-5-21-3623811015-3361044348-30300820-1013
- Primary Group SID: S-1-5-21-3623811015-3361044348-30300820-513
- Default DACL:
  - ACEs:
    - Allow: S-1-5-32-544 (Administrators)
    - Allow: S-1-5-32-545 (Users)
    - Deny: S-1-5-32-546 (Guests)
    - ...
- Source:
  - Source Name: User32
  - Source LUID: 0x3e7
- Impersonation Level: SecurityImpersonation
- Token Type: TokenPrimary
- Token ID: 0x1f4
- Authentication ID: 0x3e7
- Modified ID: 0x1f5
- Expiration Time: Infinite
```

Manipulating, accessing, and using security tokens is part and parcel for Windows malware. We will into more detail on this later on.

### Dllhost.exe

`dllhost.exe` stands for "Dynamic Link Library Host". We'll talk more about DLLs soon, but for now, just understand that a DLL is a file containing code that can be reused, but a DLL cannot be run as a standalone process, as a process must be an `exe`. `dllhost.exe` serves to enable a DLL to run like a process, which is why you will usually see multiple instances of `dllhost.exe` running. Each will host a different DLL or COM objects (more on COM later).

### NisSrv.exe

Stands for "Network Inspection Service". This process is part of the Windows Defender Firewall, performing traffic inspection and enforcing network security policies.

### Other Processes

I encourage you to go through the list and independently research what each process does. Some will be uninteresting to you, others can be deep rabbit holes worthy of their own papers and books.

## Binary and Library File Formats