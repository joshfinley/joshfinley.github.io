+++
title = "Red Teamer's Guide to Malware Development 1"
date = 2024-05-16T01:39:01-05:00
draft = false
+++

> This is a guide for malware development for ethical red teaming. Nowadays, there are lots of paid courses that cover these same concepts, but fortunately for everyone, these not necessary to get up to speed. Most of the techniques these courses cover are open source.

This is the first entry in a series that will cover everything needed to get up to speed for more advanced studies in malware development. This is a field that is both deep and broad. Important concepts in malware development involve topics in operating system architecture, low-level programming, binary exploitation, and reverse engineering. Malware development is a very intense subject once you get past the intermediate level.

This course will focus on Windows X86_64 malware.

The following topics will be covered in this entry:

1. Introduction to malware
2. Operating system basics
3. Diving into the structure of a process


## Introduction to Malware

Malware is software that does something bad. You usually want software to be useful, like assist you in writing emails or documents, do your taxes, or relax with a video game. Malware isn't helpful or beneficial. It might pretend to be something that is, but malware is essentially software that might:

- Steal your private data
- Farm your system resources for profit
- Harm your business 
- Enable fraud, scams, or even just annoying advertising

There are different names for different types of malware (spyware, trojans, viruses, etc.). These have sometimes overlapping definitions, so we don't need to really bother with them here.

In our context as red teamers and penetration testers, malware enables us to achieve our goals in finding flaws in our customer's organizations. An example is a post-exploitation implant, which we execute on a victim host in order to pilfer the filesystem, expand our access to other systems, or demonstrate compromise.

Additionally, there are programs we consider "attack tools" which may facilitate specific types of attacks. One example could be [Mimikatz](https://github.com/gentilkiwi/mimikatz), a fully featured tool used for Windows authentication attacks. We might deploy attack tools from an implant or run them independently. Attack tools and implants will be the focal point of this series.

### Functions of an Implant

An implant will usually have one or more of the following capabilities:

- Information gathering (network, processes, files)
- Run additional code on the target
- Execute shell commands
- Communication with attacker controlled servers (command and control or C2)
- (sometimes) Evasion techniques

###  Functions of an Attack Tool

An attack tool enables us to achieve our goals in an assessment. Examples include tools which:

- Allow us to use or attack certain services (E.g., [evil-winrm](https://github.com/Hackplayers/evil-winrm))
- Access credentials and authentication material (E.g., [Mimikatz](https://github.com/gentilkiwi/mimikatz))
- Escalate privileges (E.g., [SharpUp](https://github.com/GhostPack/SharpUp?tab=readme-ov-file))
- Attack authentication protocols / perform MITM attacks(e.g., [ntlmrelayx](https://github.com/fortra/impacket/blob/master/examples/ntlmrelayx.py))
- And much more.

Some attack tools we can run from our own machines, others we will need to execute on our victims.

## Operating Systems Basics

To write high quality, evasive malware you need to have three ingredients:

1. A purpose
2. Coding skills
3. Operating systems knowledge

**Purpose**

What is the point of the malware? Is it an implant? Is it an attack tool? What is it supposed to enable us to achieve?

**Coding Skills**

We need to be able to write code in the necessary language and understand how it works as much as we can. This is especially important if you have to evade security tools. Copying and pasting other people's code will only get you so far and carries greater risk - if you don't know how your off-the-shelf precompiled attack tool works, how can you be sure there is not a backdoor in it that will get YOU breached?

**Operating Systems Knowledge**

Doing useful things means at least knowing what the operating system makes available to us. It is our broker and enabler, but it can also facilitate defense tools catching us. If we hope to evade defenses, we need to know how they work, meaning how they leverage the operating system to detect and destroy our malware.

### The Purpose of the Operating System

Fun fact: you can use a computer without an operating system. It's probably not particularly enjoyable or efficient, though. The operating system serves three main purposes, which are closely interrelated:

- Abstraction: Most of us really don't want to think about machine language, circuits, physical memory, and physical storage device internals when we use our computers. We want this *simplified* away for us. We want the drive represented as just a drive and its use as simple as dragging and dropping. Abstraction of these messy details is the most important concept.

- Ease of use: Abstraction leads into ease of use. I can guarantee you nobody wants to manually designate the cylinder, track, sector, and block of the location we want to store a cat picture. We want to just put it on a specific drive and have the rest figured out for us. We also don't want to write the code that tells the hardware how to do it. We want a driver (that someone else wrote) to just do it for us.

- Stability: When we do something like move a folder containing precious family pictures, we don't want the operating system to crash and destroy our data. We want the system to be fault-tolerant, able to recover from errors, and present a seamless user experience.

The operating system aims to achieve all of these goals.

### User-mode Versus kernel-mode

The below diagram might be messy, but it provides a reasonable overview of the Windows OS. For now, we can ignore most of the white boxes inside the grey "Executive" block, as well as the "integral subsystems", "environment subsystems", "microkernel" and "hardware abstraction layer".

Instead, we will turn our focus to the three big chunks: user-mode, kernel-mode, and hardware.

![Credit to Wikipedia for this diagram](/Windows_2000_architecture.svg.png)

User-mode is where all our day-to-day applications and processes live. Microsoft Word, Slack Desktop, the Command Prompt, all of these are user-mode processes. The kernel-mode is where the operating system and device drivers live.

### User-mode Abstraction

What does abstraction mean in this context? For the most part, it really just means hiding details. For example, modern computers can run multiple (dozens, hundreds) of processes at once. Each process needs its own threads to execute in and a region of memory to store code and data. But there might be dozens or even hundreds of processes all running at the same time. How does a process ensure it doesn't overwrite memory used by another process? How does it ensure it doesn't just take over a thread of another process?

The answer is, it doesn't. Processes (in user-mode) are gleefully unaware of the nasty details of how they run. To the process, it has access to the full system memory, and it is the only executor of threads. It need not check to see if another process is using threads or memory because it's the only one it is aware of! Obviously, this is an illusion. Other processes are running, and probably even using the same physical hardware threads for executing code. But the operating system hides all this and presents a neat, tidy, isolated execution space for each user-mode process. The spaghetti underneath is *abstracted* away, hidden from view. In addition, changes in CPU design have enabled this separation with operating modes, specifically real mode vs. protected mode. Access to memory is restricted at the hardware level, in addition to being physical memory being abstracted away by the operating system.

This also provides a security barrier. Because the process only has access to a mostly blank chunk of memory, it can't see memory for other processes without being deliberately granted that access by the operating system. In many cases, the operating system just does not allow certain things to be accessed by user-mode processes. This wasn't always the case. Back in the days of Microsoft DOS, everything, including user processes, ran at the same privilege level. The kernel (core of the DOS operating system) still provided useful abstractions, but did nothing to provide essential isolation features or to protect itself from modification. This meant that processes had access to all memory and hardware. A piece of malware could essentially do anything it wanted.

### Hexadecimal

Before we continue, it is essential to understand and not be afraid of hexadecimal. In computers, just about every memory address and value we will see will often be represented in hex. Hexadecimal makes it easier to represent and work with binary numbers. It is a notation that was chosen specifically based on how we organize binary data in computers. Since the smallest addressable unit of memory is the byte (eight bits), each byte can be represented by two hexadecimal digits. The number line for hexadecimal runs through the (decimal) number 15. Including zero, a single hexadecimal digit can represent 16 possible values. The hex number line looks like this:

```
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
```

Counting by eights is easier in hexadecimal because the base-16 system allows us to quickly see patterns and transitions. Here's a demonstration of counting by eights in both decimal and hexadecimal:

**Decimal:**
```
0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128
```

**Hexadecimal:**
```
0x0, 0x8, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38, 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x
```

Every transition happens at 0x8 and 0x10, 0x18 and 0x20, making it easier to recognize and follow the increments. Memory on a computer is grouped with the smallest unit being the byte, which is represented by two hex digits. Memory locations (where data can be stored and accessed quickly) are labeled with addresses. These addresses are always represented in hex because the unit of data in use is the byte. Comparing addresses in hexadecimal notation vs decimal notation makes the utlity of hex much more obvious:

Hexadecimal:
```
0x7FFFFA0000, 0x7FFFFA0008, 0x7FFFFA0010, 0x7FFFFA0018, 0x7FFFFA0020
```

Decimal:
```
140737467146240, 140737467146248, 140737467146256, 140737467146264, 140737467146272
```

Its clear that the hex representation is much easier to read. Not only is it shorter, but the increments of data are more plainly visible.

### Virtual Memory

I've touched on virtual memory several times now, but the concept is so important it deserves its own section. An important question here is "why is it called virtual?"

This is to distinguish this memory from physical memory. It is essentially simulated. Sure, the real bytes sit in real RAM somewhere, involving real matter and electrical charges, but the way this is represented to the process is an illusion. The process sees an available region of memory locations, each with an address.  As mentioned before, these addresses are labels for a data storage location and are represented in *hexadecimal* notation. 

The process just sees a large chunk of contiguous memory that it can use as it needs. In gritty reality, the actual physical location on the stick of RAM could be anywhere. The operating system maintains a complex mapping of all available physical memory and will pick and choose where to put the data. This means while the chunk of memory looks contiguous to the process, each location might be non-sequential on the stick of RAM. 

```
+-----------------------+        +-----------------------+
|   Virtual Memory      |        |    Physical Memory    |
+-----------------------+        +-----------------------+
| Address    | Value    |        | Address    | Value    |
+------------|----------+        +------------|----------+
| 0x00000000 | 0x1A2B3C |------->| 0x0FFA1C6A | 0x1A2B3C |
+------------|----------+        +-----------------------+
| 0x00000004 | 0x2B3C4D |----+   | ...                   |
+------------|----------+    |   +-----------------------+
| 0x00000008 | 0x3C4D5E |-+  +-->| 0x1FFC734F | 0x2B3C4D |
+------------|----------+ |      +-----------------------+
                          |      |...                    |
                          |      +-----------------------+
                          +----->| 0x2FFD732A | 0x2B3C4D |
                                 +-----------------------+
```

## The Structure of a Process

In general, a process needs two things: a means to execute code, and memory.

In practice, this manifests as:

- Threads (for execution)
- Heap, stack, mapped, and reserved memory (for data storage)

Each thread has its own *stack*. Each stack is a region of memory the thread uses to store things like variables and arguments to functions. The thread interacts directly with the stack very frequently during execution. The stack is usally fixed in size, although its size can be modified. Data stored in the stack is usally smaller.

The *heap* may or may not by an application, but on Windows, each process has a built-in heap. The heap allows for a more dynamic and persistent storage location. The heap is often used for larger allocations, such as in the case of buffering an image.

The process also may have memory not associated with a stack or heap. Every windows process will have some blocks of *mapped* memory, which usually contains metadata about the process and its dependencies. The process may also request *reserved* memory from the operating system, which is usable for holding data but is not considered a stack or a heap and may be used in a somewhat free-flowing manner.

### Code: Data vs Execution

The code (instructions to execute) of a process is also stored in memory. The *thread* will run through the instructions in this region and execute them. The thread runs instructions for the CPU. These are operations like addition, subtraction, multiplication, as well as logical operations (decisions), and memory manipulation operations. 

Each thread has an *execution context*. In addition to virtual memory, an executing thread has access to a set of *registers* that store data. These registers are also places where we can store memory, but registers are even more fast and convenient for the thread to use than RAM. The caveat is much less data can be stored in registers than in memory.

Our program code is always translated at some point to machine code that the processor can understand. The operating system keeps track of our processes thread, stacks, heaps, reserved memory, mapped memory, and registers.


### Thread Context

The threads execution context is the combination of the registers (very quickly accessible but small units of memory).

The x86_64 thread context looks something like this (with a few simplifying omissions):

```
+------------------------------------+
|           Thread Context           |
+------------------------------------+
| Control Registers                  |
|------------------------------------|
| RIP (Instruction Pointer)          |
| RSP (Stack Pointer)                |
| RFLAGS (Flags Register)            |
+------------------------------------+
| General Purpose Registers          |
|------------------------------------|
| RAX                                |
| RBX                                |
| RCX                                |
| RDX                                |
| RSI                                |
| RDI                                |
| RBP                                |
| R8                                 |
| R9                                 |
| R10                                |
| R11                                |
| R12                                |
| R13                                |
| R14                                |
| R15                                |
+------------------------------------+
| Segment Registers                  |
|------------------------------------|
| CS (Code Segment)                  |
| DS (Data Segment)                  |
| ES (Extra Segment)                 |
| FS (FS Segment)                    |
| GS (GS Segment)                    |
| SS (Stack Segment)                 |
+------------------------------------+
| Debug Registers                    |
|------------------------------------|
| DR0                                |
| DR1                                |
| DR2                                |
| DR3                                |
| DR6                                |
| DR7                                |
+------------------------------------+
| Floating Point and Vector Registers|
|------------------------------------|
| XMM0                               |
| XMM1                               |
| XMM2                               |
| XMM3                               |
| XMM4                               |
| XMM5                               |
| XMM6                               |
| XMM7                               |
| XMM8                               |
| XMM9                               |
| XMM10                              |
| XMM11                              |
| XMM12                              |
| XMM13                              |
| XMM14                              |
| XMM15                              |
+------------------------------------+
| Miscellaneous State                |
|------------------------------------|
| MXCSR (Control/Status Register)    |
| FPU Control Word                   |
| FPU Status Word                    |
| FPU Tag Word                       |
| FPU Instruction Pointer            |
| FPU Data Pointer                   |
| FPU Opcode                         |
+------------------------------------+
```

Segment, debug, floating point, vector, and miscellaneous state registers can be ignored for now. Instead, focus on the control registers and general purpose registers. Each register has a specific purpose, outlined below:

**Control Registers**

- RIP (Instruction Pointer): Holds the memory address of the next instruction to be executed
- RSP (Stack Pointer): Points to the top of the current stack (memory)
- RFLAGS (Flags Register): Status flags, control flags, and system flags. These flags are important as they can be set by certain CPU instructions (such as comparion operations) and result in the change of RIP to different locations (as one example).

**General Purpose Registers**

- RAX: Accumulator register, used for arithmetic operations and to store function return values.
- RBX: Base register, often used to store addresses of data.
- RCX: Count register, used for loop counters and string operations.
- RDX: Data register, used in I/O operations and to hold function arguments.
- RSI (Source Index): Source index for string operations, points to source data in memory.
- RDI (Destination Index): Destination index for string operations, points to destination data in memory.
- RBP (Base Pointer): Base pointer for the current stack frame, used to reference local variables.
- R8 - R15: Additional general-purpose registers available in x64 architecture, used for extended function arguments and calculations.

Note that these general purpose registers are freely modifiable by CPU instructions. What is most important to understand is the operating systems *conventions* for interacting with these registers. It will look different on different systems. How each register is supposed to be used is defined by the platforms ABI or Application Binary Interface. The ABI specifies which registers are used for which purposes, and rules for preservation of the values in the registers between function calls. We'll talk about this more later.

A given execution state of a thread in a process will look something like this:

```
+-----------------------------------+       +-----------------------------------+
|            Code Segment           |       |                CPU                |
+-----------------------------------+       +-----------------------------------+
| 0x00400000: mov rax, 1            |       | Registers:                        |
| 0x00400005: add rax, rbx          |       | +-------------------------------+ |
| 0x00400008: cmp rax, rcx          |       | | RIP    (Instruction Pointer)  | |
| 0x0040000B: je  0x00400015        |       | | +---------------------------+ | |
| 0x0040000D: sub rax, 2            |       | | | 0x00400005 (add rax, rbx) | | |
| 0x00400010: jmp 0x00400020        |       | | +---------------------------+ | |
| 0x00400015: xor rax, rax          |       | |                               | |
| 0x00400018: ret                   |       | +-------------------------------+ |
| 0x00400020: inc rax               |       | | General Purpose Registers     | |
| 0x00400022: ret                   |       | | +---------------------------+ | |
|                                   |       | | | RAX: 0x01                 | | |
|                                   |       | | | RBX: ???                  | | |
|                                   |       | | | RCD-R15: ???              | | |
|                                   |       | | +---------------------------+ | |
|                                   |       | |                               | |
|                                   |       | | RSP (Stack Pointer)           | |
|                                   |       | | +---------------------------+ | |
|                                   |       | | | Value: ...                | | |
|                                   |       | | +---------------------------+ | |
|                                   |       | |                               | |
|                                   |       | | RBP (Base Pointer)            | |
|                                   |       | | +---------------------------+ | |
|                                   |       | | | Value: ...                | | |
|                                   |       | | +---------------------------+ | |
|                                   |       | |                               | |
|                                   |       | +-------------------------------+ |
|                                   |       | | RFLAGS (Flags Register)       | |
|                                   |       | | +---------------------------+ | |
|                                   |       | | | Value: ...                | | |
|                                   |       | | +---------------------------+ | |
|                                   |       | +-------------------------------+ |
+-----------------------------------+       +-----------------------------------+
```

See that next entry [here](/posts/2024-5-17-malware-development-2/).