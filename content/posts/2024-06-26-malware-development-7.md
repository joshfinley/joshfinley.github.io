+++
title = "Red Teamer's Guide to Malware Development 7: Cobalt Strike"
date = 2024-06-19T12:13:12-05:00
draft = true
+++

> This is a guide for malware development. Nowadays, there are many paid courses that cover these same concepts, but fortunately for everyone, these not necessary to get up to speed. Most of the techniques these courses cover are open source.

## Introduction

Cobalt Strike is a popular post-exploitation and command-and-control framework owned by Fortra. Originally developed by Rafael Mudge as an extension to Metasploit, Cobalt Strike is used by red teams and threat actors worldwide for offensive operations. It was first announced by Rafael Mudge [in June of 2012](https://www.cobaltstrike.com/blog/meet-cobalt-strike-adaptive-pen-testing).

From its humble beginnings as an outshoot of the [Armitrage project](https://www.offsec.com/metasploit-unleashed/armitage/), Cobalt Strike has continually evolved to keep pace with advancements in CyberSecurity. Today it boasts one of the largest user bases of any attack tool of its kind globally, and has even been used in advanced persistent threat campaigns like [APT29's Solar Winds supply chain attack](https://cloud.google.com/blog/topics/threat-intelligence/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor).

Cobalt Strike has become so popular that the use of unlicensed, cracked, and stolen versions in real threat actor campaigns triggered a [Europol Global Action](https://www.europol.europa.eu/media-press/newsroom/news/europol-coordinates-global-action-against-criminal-abuse-of-cobalt-strike) targeting criminal use of Cobalt Strike. The prevalence of its use by real threat actors is a testament to the tools effectiveness in enabling offensive operations.

#### What is a Post Exploitation Framework?

Imagine we have a classic scenario of an RCE vulnerability in Microsoft IIS, running on a Windows server. We know we can exploit this, but we want quickly migrate into a standalone process on the server, as to not disrupt any services. We also want to examine the host for any loot or opportunities to pivot further into the target network. With a post exploitation framework like Cobalt strike, we can achieve all of these aims with one payload.

Once Beacon has been launched and is successfully running, we now have much greater flexibility. The following table provides a brief overview of the commands we have available:

Plausible first steps might be to pilfer the filesystem for secrets or evaluate any direct opportunities for privilege escalation. For the first, we have commands to access the filesystem and read whatever files we have access to. For the second, we may wish to deploy additional tools (the built in privilege escalation commandlets for Beacon will very rarely work). We might notice that we have `SeImpersonatePrivilege`, and the Windows Server version is subject to an impersonation exploit. 

> TODO

## Cobalt Strike Components

Cobalt Strike is comprised of two essential components: the Beacon, and the Teamserver. The Teamserver is the command and control listener which manages the malware implants (called *Beacon*) on victim machines. The user interacts with the Teamserver through its client interface. From here, the user is able to deploy listeners like HTTP(S) and DNS servers which are able to send and receive data to/from Beacons. The user interfaces with the Teamserver to issue commands to Beacons and receive results.

The teamserver is the component which manages all the runtime components of the Cobalt Strike framework. It keeps track of beacons and listeners, and exposes functionality to generate payloads and even the running of web servers for hosting malicious content.

When setting up a Teamserver in order to deploy a beacon to a target, the minimum setup includes specfiying which address for the Teamserver to receive connections on, a password for authentication, and setting up a listener.

![Example of an HTTP listener in Cobalt Strike](/listener-example.png)

The listener is the connection point that Beacons deployed on targets will call back to. When you generate a beacon, the Teamserver will embed that beacon with information on whichever listener you choose, so that Beacon knows where to call back to.

 As of Cobalt Strike 4.10, there are nine types:

| Listener Type | Process Description                                                                                                                         |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| DNS           | Commands are transmitted via DNS queries and responses, with the Beacon decoding and executing them, then sending results back through DNS. |
| HTTP          | Commands are encoded into HTTP requests, retrieved by the Beacon during its polling, executed, and results are sent back via HTTP.          |
| HTTPS         | Similar to HTTP, but commands and results are transmitted over an encrypted HTTPS connection.                                               |
| SMB           | Commands are sent through SMB named pipes, executed by the Beacon, and results are returned over the same channel.                          |
| TCP           | Commands are transmitted over a raw TCP connection, the Beacon decodes and executes them, then sends results back through TCP.              |
| External C2   | Commands and results are managed through an external C2 server, integrating custom protocols or services for communication.                 |
| Foreign HTTP  | Allows passing a session to a Metasploit Framework HTTP handler. Allows passing a session from Cobalt Strike to MSF                         |
| Foreign HTTPS | Similar to Foreign HTTP, but communication is encrypted with HTTPS                                                                          |

## Customizing Cobalt Strike

A common complaint about Cobalt Strike is that, in the present, anti-malware efforts have outpaced Cobalt Strike development, making it less than ideal for use in real operations. While it is true that getting away with stock and even customized Cobalt Strike has become much more difficult, the reality is that this happens for any successful tool in the space. Compteting products, such as [Nighthawk](https://www.mdsec.co.uk/nighthawk/) and [Brute Ratel](https://bruteratel.com/) have emerged as alternatives. While these products retain all the core functionality modeled by Beacon, they fill a gap in the market for red teams who wish to retain all the advanced functionality of a post exploitation framework, but without the effort needed to keep up with latest anti-malware techniques. Cobalt Strike, on the other hand, relies heavily on the customer to customize the product to suit their needs. To that end, Cobalt Strike's developers have continually released features to improve the product's flexibility and facilitate custom development for the code that loads and protects Beacon. 

The three major features and tools for Cobalt Strike customization are the Arsenal Kit, Malleable C2, and Aggressor Scripts. Between the three, the user is able to configure payload generation, Teamserver behavior, Beacon behavior, and network indicators from Beacon communications with its command and control listeners.

### Arsenal Kit Overview

To facilitate custom development, the developers of Cobalt Strike released the *Arsenal Kit*, as a kind of SDK for Cobalt Strike. While most of Beacon itself is static, the Arsenal Kit provides utilities and templates for developing custom loaders for beacon, and modifying components which protect beacon when it is vulnerable (i.e., unencrpyted).

### Malleable Command and Control

In addition to code protetction, Cobalt Strike offers customization in the form of configuration options which allow modification of network activity generated by Cobalt Strike. The feature implementing this is dubbed *Malleable C2*. [Public examples](https://github.com/BC-SECURITY/Malleable-C2-Profiles) of Malleable C2 profiles (configurations) demonstrate the flexibility of the feature. There are dozens of publicly available profiles simulating the network indicators of real-world malware families and demonstrating more covert methods.

### Aggressor Scripts

Aggressor Script is a scripting engine and language built into Cobalt Strike. It has become a [core component](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics_aggressor-scripts/as_cobalt-strike.htm) of the Cobalt Strike framework. Interacting with Beacons and Listeners, configuring menus,
customizing reports, and even modifying Cobalt Strike components are all possible with Aggressor scripts.

## A Deep Dive Into Beacon

Beacon is the core payload of Cobalt Strike. It is the component facilitating our actions on a target.

At its core, Beacon is a Windows Executable file, although it is a bit unusual. By default, when a user generates a stageless Beacon executable (a common task), Beacon itself is nested within one or more loading layers which are resonsible for setting up the execution environment Beacon needs. The default Beacon EXE generator will generate a Beacon EXE that is packaged alongside a position independent reflective loader. This will then be packaged into a valid EXE that will spawn the reflective loader, which will then spawn Beacon.

```
Packing Structure:

                +-----------------------------------+
                |           Main EXE Loader         |
                |  +-----------------------------+  |
                |  |    Reflective Loader        |  |
                |  |  +---------------------+    |  |
                |  |  |                     |    |  |
                |  |  |    Beacon Payload   |    |  |
                |  |  |                     |    |  |
                |  |  +---------------------+    |  |
                |  |                             |  |
                |  +-----------------------------+  |
                |                                   |
                +-----------------------------------+

Execution Chain:

    +----------------+     +-------------------+     +----------------+
    |                |     |                   |     |                |
    | Main EXE Loader| --> | Reflective Loader | --> | Beacon Payload |
    |                |     |                   |     |                |
    +----------------+     +-------------------+     +----------------+
        |                       |                        |
        |                       |                        |
        v                       v                        v
    Executes            Loads & Executes          Runs & Communicates
```

Both the Main EXE loader and the reflective loader may be replaced entirely, through the [Artifact Kit](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/artifacts-antivirus_artifact-kit-main.htm) and [User-Defined Reflective Loaders](https://www.cobaltstrike.com/product/features/user-defined-reflective-loader) respectively. For Beacon itself, through Malleable PE (defined in a Malleable C2 profile) and aggressor script, we are able to modify some of the functionality of Beacon.  such as changing [process injection behavior](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/malleable-c2-extend_process-injection.htm?cshid=1053). Malleable PE also allows modification of some of the more well known indicators of Beacon that might be used for detection, such as the named pipes that Beacon uses for interprocess communication (IPC). 

### Beacon Post Exploitation

The core functionality of beacon is to enable post exploitation on a target. Post exploitation means what we will do using the target to advance our campaign. The following table provides a brief overview of Beacon commands:

| Action                   | Description                                    |
| ------------------------ | ---------------------------------------------- |
| Change Directory         | Change directory                               |
| Copy File                | Copy a file                                    |
| Inject DLL               | Inject a Reflective DLL into a process         |
| Download File            | Download a file                                |
| List Files               | List files                                     |
| Elevate Privileges       | Spawn a session with elevated privileges       |
| Execute Program          | Execute a program on target (no output)        |
| Execute .NET Program     | Run a local .NET program in-memory on target   |
| Dump Password Hashes     | Dump password hashes                           |
| Spawn Session            | Start a session in a specific process          |
| Start Keylogger          | Start a keystroke logger                       |
| Terminate Process        | Kill a process                                 |
| Dump Credentials         | Dump credentials and hashes with mimikatz      |
| Set DNS Mode             | Use DNS as data channel                        |
| Move File                | Move a file                                    |
| Network Enumeration      | Network and host enumeration tool              |
| Scan Network             | Scan a network for open services               |
| Run PowerShell           | Execute a command via PowerShell               |
| Inject PowerShell        | Execute PowerShell command in specific process |
| Pass-the-Hash            | Pass-the-hash using Mimikatz                   |
| Print Directory          | Print current directory                        |
| Query Registry           | Query the registry                             |
| Remote Execution         | Run a command on a remote host                 |
| Remove File              | Remove a file or folder                        |
| Reverse Port Forward     | Set up a reverse port forward                  |
| Run Program              | Execute a program on target (returns output)   |
| Run as Admin             | Execute a program in an elevated context       |
| Set Environment Variable | Set an environment variable                    |
| Execute Shell Command    | Execute a command via cmd.exe                  |
| Inject Shellcode         | Inject shellcode into a process                |
| Set Sleep Time           | Set beacon sleep time                          |
| Start SOCKS Server       | Start/Stop a SOCKS server to relay traffic     |
| Start Session            | Start a session                                |
| Steal Token              | Steal access token from a process              |
| Apply Timestamps         | Apply timestamps from one file to another      |
| Upload File              | Upload a file                                  |

### The Beacon Reflective Loader

A common source of confusion is the Beacon reflective loader. Lets suppose we generate a Windows x64 stageless Beacon. The output file will be a valid Windows PE file with a very small `.text` section (for the executable code) and a very large `.data` section (for the Beacon reflective loader and payload). This outer wrapper is a pure shellcode runner, which means that all it does is load the raw bytes (the shellcode) of the payload and start executing them. It trusts that those bytes know what they're doing.

If we load this plain stageless beacon executable in a debugger and break on the first `VirtualAlloc`, we will spot this same code being loaded into memory at the address `VirtualAlloc` returned. The shellcode runner / wrapper will decrypt the blob in the data section mentioned earlier and write it to this new buffer, and then spawn a thread at the base of the same buffer.

If you were to look at this address in a hexdump, you would see that there is the familiar `MZ` signature at the first bytes of the code, but followed by `ARUH` (0x41525548), together `MZARUH`. Shortly after, we see the DOS stub, so what we're looking at appears to be a PE file, albeit a mangled one. Importantly, this apparent DLL header is marked executable just prior to `CreateThread` being executetd. What is happening? Are we looking at data or code?

The answer is both. While this is indeed the MZ header of a DLL, the same bytes are getting ready to load Beacon. What we are looking at is the MZ header of Beacon itself, as if it were sitting on disk (meaning it is not yet memory mapped). Remember that EXE and DLL files are arranged differently in memory than on disk. Ordinarily, the Windows PE loader would read our program headers and create a memory mapped version in our process address space. This DLL we are looking is indeed Beacon, but it is in its unmapped state. It must be mapped into memory before it will be fully up and running.

[These two states](https://www.cobaltstrike.com/blog/cobalt-strike-and-yara-can-i-have-your-signature) of the Beacon DLL are the "raw" Beacon DLL and the "virtual" Beacon DLL. "Raw" is the unmapped state, and "virtual" is the state that is ready to run and dispense post exploitation jobs. But going back to the debugger, we left off at the curious `MZRAUH` bytes in the Beacon DLL header. In fact, these bytes are a *stub* which will calculate an offset of the current Beacon DLL and call it (i.e., an export in the same DLL). These stub bytes simply serve to transfer control flow to the export, named by default `ReflectiveLoader`. `ReflectiveLoader` will then copy the bytes of its own DLL image into the final virtual state. `ReflectiveLoader` will return the final, virtual address of Beacon's DLL main function for the stub to execute at last.

The Beacon reflective loader is based on the Stephen Fewer's [classic proof-of-concept](https://github.com/stephenfewer/ReflectiveDLLInjection).

```
+-------------------------------------------------------+
|                  Target Process                       |
|                                                       |
| +------------------------------+   +----------------+ |
| | Raw Beacon DLL               |   | New Memory     | |
| |                              |   | Page (Virtual  | |
| |                              |   | Beacon DLL)    | |
| | +----------------------------+   | +------------+ | | 
| | | MZ Header (Stub)           |   | | Mapped DLL | | |
| | |                            |   | |            | | |
| | | 1. Find ReflectiveLoader   |   | | [Fully     | | |
| | | 2. Call ReflectiveLoader   |+--> | loaded and | | |
| | | 3. Call DLL Main           |   | | relocated  | | |
| | +----------------------------+   | | DLL]       | | |
| |           |                  |   | +------------+ | |
| |           |                  |   | - New          | |
| |           v                  |   |   Entry        | |
| | +------------------------+   |   |   Point        | |
| | | ReflectiveLoader       |   |   |                | |
| | | (Exported Function)    |   |   +----------------+ |
| | |                        |   |                      |
| | | 1. VirtualAlloc        |   |                      |
| | | 2. Map DLL to new page |   |                      |
| | | 3. Perform relocations |   |                      |
| | | 4. Resolve imports     |   |                      |
| | | 5. Jump to new         |   |                      |
| | |    entry point         |   |                      |
| | +------------------------+   |                      |
| |                              |                      |
| +------------------------------+                      |
|                                                       |
+-------------------------------------------------------+
```

## References

- https://naksyn.com/cobalt%20strike/2024/07/02/raising-beacons-without-UDRLs-teaching-how-to-sleep.html
- https://www.cobaltstrike.com/blog/process-injection-update-in-cobalt-strike-4-5
- https://www.cobaltstrike.com/blog/cobalt-strike-49-take-me-to-your-loader
- https://www.cobaltstrike.com/product/features
- https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/agressor_script.htm
- https://www.cobaltstrike.com/blog/cobalt-strikes-process-injection-the-details-cobalt-strike
- https://securityintelligence.com/x-force/defining-cobalt-strike-reflective-loader/
- https://www.cobaltstrike.com/blog/cobalt-strike-and-yara-can-i-have-your-signature
- https://github.com/CCob/BeaconEye