+++
title = "Red Teamer's Guide to Malware Development 3: Custom Thread Stack"
date = 2024-05-16T11:39:01-05:01
draft = false
+++

> This is a guide for malware development for ethical red teaming. Nowadays, there are lots of paid courses that cover these same concepts, but fortunately for everyone, these not necessary to get up to speed. Most of the techniques these courses cover are open source.

This entry will take you deep into Windows process internals, focusing on the thread stack. Recall that the stack is a region of memory created per-thread, where the thread will store components of the execution state. Data like parameters, return addresses, and certain types of variables are all stored on the stack. This article will cover, with code examples, creating **and** managing a custom thread stack. 

### Relevance to Security

While this project might seem like an unrelated programming rabbit hole, the topics covered will help in:

- **Understanding Thread Stack Manipulation:** Creating a custom managed stack for a thread involves intricate stack and memory manipulation, which is frequently needed in malware and exploit code. An example might be stack encryption during an implant sleep cycle or modification before a system call.
- **API Knowledge and Abstraction:** In this project, we will work with a variety of API calls that are also used in malware and anti-malware context.
- **Grasping Exception Handling:** SEH and VEH are covered in this project. These exception handling mechanisms are commonly used by malware, anti-malware, and exploit developers due to their powerful ability to affect control flow and handle unexpected situations.
- **Visualizing Stack Overflow and Guard Pages:** Stack overflows are a staple concept in exploit development. In this article we discuss *in depth* how an overflow might happen and how the OS might handle one.


## Thread Creation APIs

Each thread has its own stack. There may be many threads in a single process, but the OS APIs we use to create a new thread do this for us. The most commonly used APIs for creating a new thread is `CreateThread`, part of the Windows API. 

On my system (Windows 10 version 2009), `CreateThread` is exported by `kernel32.dll`, but inside `kernel32.dll` it is forwarded to `KernelBase.dll`, where the actual functionality exists. Inside `KernelBase.dll`, `CreateThread` will then forward to `CreateRemoteThreadEx`. Inside, `CreateRemoteThreadEx` will eventually call `NtCreateThreadEx` to request the new thread resource from the kernel.

This means that `CreateThread` is a high-level, abstract wrapper around `NtCreateThreadEx`. The wrapper will obscure some of the internal functionality in order to offer a more streamlined experience.

Inside of the kernel, the actual handler is implemented in `PsCreateSystemThread`, which calls `PsCreateSystemThreadEx`.

The full high-level control flow thus looks like this:

```
CreateThread
|
+->CreateRemoteThreadEx
   |
   +->NtCreateThreadEx
      |
      +->PsCreateSystemThread
         |
         +->PsCreateSystemThreadEx
```

## Thread Stack Creation

After reversing the relevant kernel code, it seems that the thread stack is allocated by the kernel by a series of function calls from `PsCreateSystemThreadEx`. The stack creation appears to happen in multiple places.

```C++
uint FUN_140861df8(longlong *param_1)

{
    // Declarations


      if (...) {
        ThreadStack = ExAllocatePoolWithTag(0x200,(ulonglong **)0x20000,0x7452624f);
    }
   
   // Other logic
}
```

`ExCreatePoolWIthTag` is a kernel function that handles allocation of memory "pools" (or blocks) within the kernel. The function signature is:

```C++
PVOID ExAllocatePoolWithTag(
  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,
  [in] SIZE_T                                         NumberOfBytes,
  [in] ULONG                                          Tag
);
```

The arguments here correlate with known information about thread stack defaults. Speficically, thread stacks are allocated as NX (non-executable) on modern Windows systems with a size of `0x20000`. The argument of `0x200` [corresponds](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type) with the pool type `NonPagedPoolNx`. The `Nx` stands for 'no-execute'. So the stack size and execution permissions match what we expect. 

The hex value `0x7452624f` is a little-endian ASCII representation of the string `ObRt`. `Ob` is a reference to the Windows kernel object manager, a critical component that managers all system objects (like processes, threads, etc). The full tag `ObRt` stands for *object reference stack tracing*. 

Between these three pieces, we can be fairly certain function calls outbound from `PsCreateSystemThreadEx` with this tag, and pool type will be responsible for creating the stack memory.

## Creating a Thread in C/C++ Using the Windows API

Using the Windows API, it is easy to create new threads and memory allocations.

The `CreateThread` API is as follows:

```C++
HANDLE CreateThread(
  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  [in]            SIZE_T                  dwStackSize,
  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
  [in, optional]  __drv_aliasesMem LPVOID lpParameter,
  [in]            DWORD                   dwCreationFlags,
  [out, optional] LPDWORD                 lpThreadId
);
```

So we must pass:

- Metadata about the thread (optional)
- Size of thread (default of `0x20000` if 0 is passed)
- Use code to execute at beginning of thread
- Variable to pass to the thread
- Flags / thread creation options
- Optional output for thread ID

In code, a valid call would look something like this:

```C++
// Thread function that will use the new stack
DWORD WINAPI ThreadFunction(LPVOID lpParam) {
    MessageBoxA(NULL, "Hello", "Hello from thread with custom stack", MB_OK | MB_ICONINFORMATION);

    return;
}

int main() {
    // Create a thread
    HANDLE hThread = CreateThread(NULL, 0, ThreadFunction, NULL, CREATE_SUSPENDED, NULL);
    if (hThread == NULL) {
        std::cerr << "Failed to create thread." << std::endl;
        return 1;
    }

    // Resume the thread
    if (ResumeThread(hThread) == -1) {
        std::cerr << "Failed to resume thread." << std::endl;
        VirtualFree(newStackBase, 0, MEM_RELEASE);
        CloseHandle(hThread);
        return 1;
    }

    // Wait for the thread to finish
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
}
```

`CreateThread` will ask the system to create the new thread and returns a handle to it, if successful. A handle is an identifier representing an object managed by the operating systems. To manipulate objects like threads, processes, files, tokens, etc. you will need the operating system to give you a handle. The operating system keeps track of handles using a table inside the kernel.

`ResumeThread` is needed because we started the thread in a suspended state. It will triger the thread to start executing.

`WaitForSingleObject`, when passed a thread handle, will pause execution of the *current* thread until the new thread exits.

## Creating a Custom Stack

Thanks to some other APIs, we are able to manually modify some details about how our thread will work, either while it is executing or before it starts. The APIs we use here are `GetThreadContext` and `SetThreadContet`. These APIs work with the `CONTEXT` structure. You pass in the information of the thread, and either get out information about the thread or modify it, respectively.

The `CONTEXT` [structure](../../../../../Downloads/Est_103678_from_dba_Elite_Pool_Service_13860.pdf) will contain all the information about the state of the registers for the thread. We can first call `GetThreadContext` to [get](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext) the initial thread state, modify it, and p[ass it back](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext) to the thread using `SetThreadContext`.

This means we can overwrite RSP (stack pointer) with whatever we want. We can even write an invalid address, a location where we have written code, or a custom stack.

```C++
    // Get the context of the thread
    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext(hThread, &context)) {
        std::cerr << "Failed to get thread context." << std::endl;
        VirtualFree(newStackBase, 0, MEM_RELEASE);
        CloseHandle(hThread);
        return 1;
    }
```

With the threads context, we can now manipulate values. The kernel already allocated a memory poolA custom stack location will require a new region of memory. The best suited type for this is private memory.

```C++
    LPVOID newStackLimit = VirtualAlloc(NULL, NEW_STACK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (newStackLimit == NULL) {
        std::cerr << "Failed to allocate new stack." << std::endl;
        CloseHandle(hThread);
        return 1;
    }
```

If successful, `VirtualAlloc` will return the address of a a new region of private memory inside the process address space. We have used a typical default stack size, and have marked it as `PAGE_READWRITE`, which is similar to the non-paged NX pool the kernel would ordinarily allocate.

It might be tempting to overwrite RSP with the newly allocated memory, but we must remember the stack grows downwards. This means we need to set RSP to the *top* of the new memory region, so as the stack grows it will move toward the bottom of our allocated block of memory.

```C++
    SIZE_T newStackBase = reinterpret_cast<SIZE_T>(newStackLimit) + NEW_STACK_SIZE;
```

In the above code, we create a new variable that points to the new memory region's maximum address. There is something missing here, however, which we will see soon.

Next, we modify the context structure's stack and base pointer to the new value:

```C++
context.Rsp = newStackBase - 8;
context.Rbp = context.Rsp;
```

Finally, we can update the thread context, resume the thread, and wait for it to complete:

```C++
    // Set the updated context to the thread
    if (!SetThreadContext(hThread, &context)) {
        std::cerr << "Failed to set thread context." << std::endl;
        VirtualFree(newStackBase, 0, MEM_RELEASE);
        CloseHandle(hThread);
        return 1;
    }

    // Resume the thread
    if (ResumeThread(hThread) == -1) {
        std::cerr << "Failed to resume thread." << std::endl;
        VirtualFree(newStackBase, 0, MEM_RELEASE);
        CloseHandle(hThread);
        return 1;
    }

    // Wait for the thread to finish
    WaitForSingleObject(hThread, INFINITE);

    // Clean up
    VirtualFree(newStackBase, 0, MEM_RELEASE);
    CloseHandle(hThread);
```

Now, if you put this code together and try to run it, you will get an access violation error. This is because we have not properly *aligned* the stack. On 64 bit systems, the stack must be aligned on a memory address that is a multiple of 16. This is because certain CPU instructions require this alignment and will trigger an access violation if the alignment is incorrect. We can align the stack using the following code:

```C++
    LPVOID newStackLimit = VirtualAlloc(NULL, NEW_STACK_SIZE + 16, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (newStackLimit == NULL) {
        std::cerr << "Failed to allocate new stack." << std::endl;
        CloseHandle(hThread);
        return 1;
    }

    SIZE_T newStackBase = reinterpret_cast<SIZE_T>(newStackLimit) + NEW_STACK_SIZE;
    SIZE_T alignedStackBase = (newStackBase & ~0xF); // Align to 16 bytes
    context.Rsp = alignedStackBase - 8; // -8 to ensure the stack is 16-byte aligned after a call
    context.Rbp = alignedStackBase - 16; // -16 to leave space for a return address
```

If you run the code now, the message box should pop up, followed by another access violation error. This is because the code is attempting to return to an invalid code address when the thread returns. We can easily fix this by triggering a return to `ExitThread` instead:

```C++
    // Push the address of ExitThread onto the stack
    *reinterpret_cast<SIZE_T*>(alignedStackBase - 8) = reinterpret_cast<SIZE_T>(&ExitThread);
```

The full code is as follows:

```
#include <windows.h>
#include <iostream>

// Define the size of the new stack
const SIZE_T NEW_STACK_SIZE = 1 * 1024 * 1024; // 1 MB

// Thread function that will use the new stack
DWORD WINAPI ThreadFunction(LPVOID lpParam) {
    MessageBox(NULL, L"Hello from the new stack!", L"Custom Stack Thread", MB_OK | MB_ICONINFORMATION);
    return 0;
}
```

## Missing Features

So we have a working stack. But it is a far cry from what the system would ordinarily allocate. It is missing a number of security and stability protections which would ordinarily be in place. One important one is *guard pages*. [This](https://devblogs.microsoft.com/oldnewthing/20220203-00/?p=106215) article does an amazing job explaining stack guard pages, but the gist is that at the end of the stack there will be another region of memory, that if read or written, will trigger an exception handler.

This provides both security and stability. Access beyond the stack's boundaries will bothe be blocked and handled by the guard page, protecting other memory regions in the event of an overflow. Guard pages will come back again when we look at EDR malware mitigations.

Paired with the guard page is an exception handler, whose information is stored in the a region of memory within the process containing metadata about the thread (called the Thread Environment Block, or TEB). This structure also contains a pointer to something called the the Thread Information Block (TIB), which is where the exception list info is actually stored.

Additionally, we have not properly set some fields in the TEB/TIB. The TIB has the fields `StackBase` and `StackLimit`, which should be modified. We didn't see any errors with the previous code because of this, but its highly likely that some future operations by the OS or compiler on the thread will fail if these are incorrect (see [this](https://stackoverflow.com/questions/57564731/how-to-set-the-address-of-a-thread-stack-in-win32)).

We can handle the TIB with a function:

```C++
pNtQueryInformationThread GetNtQueryInformationThread() {
    HMODULE hNtDll = GetModuleHandleA("ntdll.dll");
    if (hNtDll == NULL) {
        std::cerr << "Failed to get ntdll module handle." << std::endl;
        return NULL;
    }
    pNtQueryInformationThread NtQueryInformationThread = (pNtQueryInformationThread)GetProcAddress(hNtDll, "NtQueryInformationThread");
    if (NtQueryInformationThread == NULL) {
        std::cerr << "Failed to get NtQueryInformationThread function address." << std::endl;
        return NULL;
    }
    return NtQueryInformationThread;
}

BOOL UpdateTib(HANDLE hThread, SIZE_T newStackBase, PVOID newStackLimit) {
    pNtQueryInformationThread NtQueryInformationThread = GetNtQueryInformationThread();
    if (NtQueryInformationThread == NULL) return FALSE;
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS status = NtQueryInformationThread(hThread, ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
    if (status != 0) {
        std::cerr << "Failed to query thread information. Status: 0x" << std::hex << status << std::endl;
        return FALSE;
    }
    PTEB teb = (PTEB)tbi.TebBaseAddress;
    PNT_TIB tib = (PNT_TIB)teb;
    tib->StackBase = reinterpret_cast<PVOID>(static_cast<ULONG_PTR>(newStackBase));
    tib->StackLimit = newStackLimit;
    std::cout << "Updated TIB: StackBase = 0x" << std::hex << tib->StackBase
        << ", StackLimit = 0x" << std::hex << tib->StackLimit << std::endl;
    return TRUE;
}
```

### Protecting the Tiny Stack

At this point, we are still missing the important feature of overflow handling. This also gives us the opportunity to add in some optimization that we would otherwise be missing out on. With automatic expansion features, we can reduce the size of the initial stack. It may not be particularly useful in most context, but it is still interesting, and is a good exercise. With that in mind, the plan is to:

- Refactor the code, as the `main` block has already gotten quite gnarly
- Reduce the size of the new stack, as will now be growable
- Add guard pages
- Implement exception handling for guard page access to grow the new stack

With that in mind, lets start by shrinking the stack to a tiny 4096 bytes:

```C++
const SIZE_T NEW_STACK_SIZE = 4096;
```

When `ThreadFunction` calls `MessageBox`, it will run out of memory on the stack and trigger an access violation. We now need to redo our initial allocation to put a guard page below our stack. We will need to allocate enough meory for our guard page and our initial stack. While we are at it, we can reserve some extra memory.

```C++
#define STACK_RESERVE_SIZE (NEW_STACK_SIZE * 3)

LPVOID reserved = VirtualAlloc(NULL, STACK_RESERVE_SIZE, MEM_RESERVE, PAGE_NOACCESS);
    if (reserved == NULL) {
        std::cerr << "Failed to allocate reserved space: 0x" << std::hex << GetLastError() << std::endl;
        CloseHandle(hThread);
        return 1;
    }

    LPVOID guardPage = VirtualAlloc((PBYTE)reserved + NEW_STACK_SIZE, NEW_STACK_SIZE, MEM_COMMIT, PAGE_READWRITE | PAGE_GUARD);
    if (guardPage == NULL) {
        std::cerr << "Failed to allocate guard page: 0x" << std::hex << GetLastError() << std::endl;
        VirtualFree(reserved, 0, MEM_RELEASE);
        CloseHandle(hThread);
        return 1;
    }

    LPVOID newStackLimit = VirtualAlloc((PBYTE)reserved + NEW_STACK_SIZE*2, NEW_STACK_SIZE, MEM_COMMIT, PAGE_READWRITE);
    if (newStackLimit == NULL) {
        std::cerr << "Failed to allocate new stack: 0x" << std::hex << GetLastError() << std::endl;
        VirtualFree(guardPage, 0, MEM_RELEASE);
        VirtualFree(reserved, 0, MEM_RELEASE);
        CloseHandle(hThread);
        return 1;
    }
```

The new stack looks something like this:

```
+------------------+
|    Stack Base    |
+------------------+
|  ... (data)      |
|                  |
|                  |
|                  |
|                  |
|                  |
+------------------+
|    Stack Limit   |
+------------------+
|    Guard Page    |
|  (PAGE_GUARD)    |
+------------------+
|   Reserved Space |
+------------------+
```

In the new code, we first allocate an area that can fit three 4096 byte stacks. We leave the lowest address as `reserved` memory, meaning it hasn't mapped the new virtual memory to a real physical address yet, but has reserved it for future use. We can commit it later. We mark the whole region as `PAGE_NOACCESS` to prevent any access.

Next, the middle third (above the base `reserved` address) of that address space is committed and given both `PAGE_READWRITE` and `PAGE_GUARD` flags. Whenever an operation tries to access this memory, it will trigger an access violation exception. By default, the page guard flag is removed when this happens. We will need to handle the exception.

Finally, the high third of the block is committed as plain `PAGE_READWRITE`. This will be our initial stack.

So far, we have shrunk our stack down to a tiny 12288 bytes. A normal stack would have been 1 MIB. 

### Exception Handling for Access Violations

If we run the code now, we will hit the access violation and the program will crash. Now we need to implement the exception handler. We have a couple of options for how we do this. The first is using Structured Exception Handling (SEH), and the second is using Vectored Exception Handling (VEH).

SEH registration records occur at the thread level, with there being one default global filter for exceptions that have no matching handler (unhandled eceptions). SEH functions are registered in the thread information block (TIB).

We can access the current thread's TIB and overwrite / add a handler using the following code:

```C++
    PTEB teb = (PTEB)__readgsqword(0x30);
    PNT_TIB tib = (PNT_TIB)teb;

    static EXCEPTION_REGISTRATION_RECORD ExceptionRecord;
    ExceptionRecord.Next = tib->ExceptionList;
    ExceptionRecord.Handler = reinterpret_cast<PEXCEPTION_ROUTINE>(StructuredExceptionHandler);

    tib->ExceptionList = (PEXCEPTION_REGISTRATION_RECORD)&ExceptionRecord;
```

In the case of another thread, we have to use an NT API to get the thread's TIB address:

```C++
    pNtQueryInformationThread NtQueryInformationThread = GetNtQueryInformationThread();
    if (NtQueryInformationThread == NULL) return FALSE;
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS status = NtQueryInformationThread(hThread, ThreadBasicInformation, &tbi, sizeof(tbi), NULL);
    if (status != 0) {
        std::cerr << "Failed to query thread information. Status: 0x" << std::hex << status << std::endl;
        return FALSE;
    }
    PTEB teb = (PTEB)tbi.TebBaseAddress;
    PNT_TIB tib = (PNT_TIB)teb;

    static EXCEPTION_REGISTRATION_RECORD ExceptionRecord;
    ExceptionRecord.Next = tib->ExceptionList;
    ExceptionRecord.Handler = reinterpret_cast<PEXCEPTION_ROUTINE>(StructuredExceptionHandler);

    tib->ExceptionList = (PEXCEPTION_REGISTRATION_RECORD)&ExceptionRecord;
```

VEH is a more powerful option. From a security perspective, VEH has the benefit of the registration and records being stored purely as kernel objects. Unlike SEH, a system call is needed to modify VEH. Additionally, VEH functions at the process level. For our purposes, we can catch any access to our thread's guard page and act accordingly. There are several opportunities at hand for us to improve our custom stack.

One such opportunity is cross-thread access. It might be an unusual scenario, but it is possible that another thread may have accessed our guard page. This is highly indicitive of a serious issue in the program. By default, another thread accessing our guard page would be ignored. The guard page would be removed on access, leaving us unable to detect if our code is going to overrun the stack.

Some such opportunities are the following:

- If the accessing thread is the stack "owner", increase the stack size.
- If the accessing thread is some other thread, log detailed information about the access violation and terminate the application to prevent potential corruption or undefined behavior.
- Detecting cyclic patterns used in exploit code.

Some example handlers implementing the code would look something like this:

``` C++
// Global variables for stack management
LPVOID g_newStackBase = NULL;
LPVOID g_guardPage = NULL;
LPVOID g_newStackLimit = NULL;
DWORD g_threadId = 0;

// Example: Stack expansion
LONG CALLBACK VectoredExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo) {
    if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_GUARD_PAGE
        || ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_STACK_OVERFLOW) {
        // Check if the access violation occurred in the custom stack
        if (GetCurrentThreadId() == g_threadId &&
            ExceptionInfo->ExceptionRecord->ExceptionInformation[1] >= (ULONG_PTR)g_guardPage &&
            ExceptionInfo->ExceptionRecord->ExceptionInformation[1] < (ULONG_PTR)g_newStackLimit) {
            
            // Expand the stack
            ExpandStack();
            // Continue execution
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

// Example: Protected thread
LONG CALLBACK VectoredExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo) {
    if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_GUARD_PAGE
        || ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_STACK_OVERFLOW) {
        // Check if the access violation occurred in the custom stack
        if (GetCurrentThreadId() == g_threadId &&
            ExceptionInfo->ExceptionRecord->ExceptionInformation[1] >= (ULONG_PTR)g_guardPage &&
            ExceptionInfo->ExceptionRecord->ExceptionInformation[1] < (ULONG_PTR)g_newStackLimit) {
            
            // Check security context
            if (IsSecurityCriticalContext()) {
                // Terminate the application
                TerminateProcess(GetCurrentProcess(), 1);
            } else {
                // Handle the guard page violation
                return EXCEPTION_CONTINUE_EXECUTION;
            }
        }
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

bool IsSecurityCriticalContext() {
    // Determine if the current context is security-critical
    // Example: EDR keep track of running EDR threads an validate access to 
    // their stack data
    return true; // Placeholder logic
}
```

## Conclusion

Windows makes it possible for us to control many aspects of how our applications work, if we can only grasp the fundamental concepts. Memory allocations, memory protections, exception handlers, and utilities for modifying threads are all at our disposal to create and modify thread resources. With these tools, we have many opportunities for manipulating the way our threads run and achieving some interesting and useful results. Mastering these concepts will help take us to the next level in supporting our red team campaigns.