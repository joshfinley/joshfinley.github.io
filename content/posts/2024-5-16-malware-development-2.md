+++
title = "Red Teamer's Guide to Malware Development 2: Windows Architecture"
date = 2024-05-16T09:10:38-05:00
draft = false
+++

> This is a guide for malware development for ethical red teaming. Nowadays, there are lots of paid courses that cover these same concepts, but fortunately for everyone, these not necessary to get up to speed. Most of the techniques these courses cover are open source.


The following topics will be covered in this entry:

1. Whats running on your Windows system
2. Binary and library file formats
3. Windows and NT APIs

## Whats running on your Windows system

We've talked generally about the high level building blocks of a Windows system. But what does it look like in reality?

You can quickly get all processes and drivers with the following commands:

```
tasklist
driveryquery /v
```

The utility `procexp` is also useful, for a more graphical representation.

On a system with no additional user applications running, you can expect a process list like the following:

```
Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0          8 K
System                           4 Services                   0         24 K
Registry                       140 Services                   0     31,224 K
smss.exe                       464 Services                   0        420 K
csrss.exe                      556 Services                   0      2,560 K
wininit.exe                    632 Services                   0      2,048 K
csrss.exe                      640 Console                    1      3,400 K
winlogon.exe                   736 Console                    1      5,732 K
services.exe                   776 Services                   0      8,112 K
lsass.exe                      800 Services                   0     14,704 K
svchost.exe                    916 Services                   0     19,372 K
fontdrvhost.exe                944 Services                   0      1,084 K
fontdrvhost.exe                812 Console                    1      1,992 K
dwm.exe                       1040 Console                    1    151,324 K
svchost.exe                   1556 Services                   0      7,380 K
svchost.exe                  10564 Services                   0     16,808 K
svchost.exe                   5940 Services                   0      8,132 K
svchost.exe                   3932 Services                   0     17,096 K
svchost.exe                   4540 Services                   0      5,968 K
Memory Compression            2068 Services                   0     39,204 K
spoolsv.exe                   3176 Services                   0      7,152 K
blnsvr.exe                    3384 Services                   0      2,472 K
IpOverUsbSvc.exe              3440 Services                   0      5,028 K
VGAuthService.exe             3544 Services                   0      2,604 K
MsMpEng.exe                   3656 Services                   0    410,744 K
com.docker.service            2348 Services                   0     22,096 K
WmiPrvSE.exe                  4552 Services                   0     19,080 K
dllhost.exe                   4672 Services                   0      4,904 K
msdtc.exe                     5028 Services                   0      2,564 K
SearchIndexer.exe             4520 Services                   0     52,004 K
dllhost.exe                   5444 Services                   0      4,268 K
AggregatorHost.exe            5672 Services                   0      5,684 K
MpDefenderCoreService.exe     5788 Services                   0     14,064 K
NisSrv.exe                    2672 Services                   0      6,372 K
sihost.exe                    4428 Console                    1     18,804 K
taskhostw.exe                 2004 Console                    1     10,336 K
ctfmon.exe                    2008 Console                    1     14,280 K
explorer.exe                  4324 Console                    1    129,040 K
dllhost.exe                   4980 Console                    1      9,812 K
StartMenuExperienceHost.e     7976 Console                    1     69,420 K
RuntimeBroker.exe             7980 Console                    1     21,216 K
SearchApp.exe                 8284 Console                    1    187,452 K
RuntimeBroker.exe             8364 Console                    1     30,556 K
UserOOBEBroker.exe            8672 Console                    1      5,044 K
RuntimeBroker.exe            10196 Console                    1      5,064 K
SgrmBroker.exe                1052 Services                   0      5,100 K
PhoneExperienceHost.exe       7832 Console                    1     58,336 K
RuntimeBroker.exe             8536 Console                    1      3,640 K
SecurityHealthSystray.exe     9416 Console                    1      4,100 K
SecurityHealthService.exe     7680 Services                   0      8,984 K
OneDrive.exe                 11108 Console                    1     56,308 K
SystemSettings.exe            9556 Console                    1        244 K
ApplicationFrameHost.exe      2376 Console                    1     10,156 K
MusNotifyIcon.exe             7244 Console                    1      2,152 K
msedge.exe                    5360 Console                    1    100,716 K
msedge.exe                   10568 Console                    1      7,556 K
msedge.exe                    1676 Console                    1     25,240 K
msedge.exe                    7468 Console                    1     28,788 K
msedge.exe                    4476 Console                    1     17,348 K
MoUsoCoreWorker.exe           7252 Services                   0     18,524 K
taskhostw.exe                 5696 Console                    1      7,636 K
TrustedInstaller.exe          7864 Services                   0      8,024 K
TiWorker.exe                  9540 Services                   0     11,316 K
LockApp.exe                   9012 Console                    1     51,240 K
RuntimeBroker.exe             9836 Console                    1     38,332 K
TextInputHost.exe             4280 Console                    1     44,616 K
BackgroundTransferHost.ex     2108 Console                    1     22,960 K
WindowsTerminal.exe           5340 Console                    1     86,920 K
OpenConsole.exe               6864 Console                    1      8,820 K
powershell.exe                9700 Console                    1     74,616 K
RuntimeBroker.exe             5248 Console                    1     12,964 K
tasklist.exe                  6768 Console                    1      9,200 K
```

The following sections delve into the most important processes listed above.

### System

The System process, also known as the kernel process, is responsible for handling system-level operations and kernel-mode drivers. It is a critical part of the operating system that manages low-level tasks and hardware interactions.

### Registry

This process is responsible for managing the Windows registry, a database that stores low-level settings and configurations for the operating system and applications. It handles reading and writing registry data.

### Services.exe

The Service Control Manager (services.exe) manages the starting, stopping, and interaction of system services. It ensures that all required services are running and handles their dependencies. It also handles service configuration, monitoring, dependencies, and communication.

### Svchost.exe

Notice that there are multiple instances of something called `svchost.exe` running. Why is this?

`svchost.exe` stands for Service Host, and is an integral OS component. Services on windows are background processes which perform various functions. So each `svchost.exe` process will correspond to unique services. Services are grouped and organized based on various parameters, and each group gets its own process {{< reference content="https://learn.microsoft.com/en-us/windows/application-management/svchost-service-refactoring" >}}.

You can fetch the associated service of a `svchost.exe` process with `tasklist /svc /fi "imagename eq svchost.exe"`.

### Lsass.exe

`lsass.exe` might be the most abused process in all of Windows. This is because it is the user-mode process that handles all of the authenticationon the system. However, not only is it responsible for performing the authentication, it will also *hold onto* authentication material, like Kerberos tickets, for their lifetime. `lsass.exe` is started during Windows initialization. When you try to logon to the computer, the `winlogon.exe` process relays your login credentials to `lsass.exe` to make the decision on whether to log you in. `lsass.exe` will validate against stored data, either locally or on a server. If everything checks out, it will generate a *security token* for use during your session. 

#### Security Tokens

The security token contains a plethora of data about your user and what it can do. The below shows an example of the data that might be contained in a security token:

```
Security Token:
- User SID: S-1-5-21-3623811015-3361044348-30300820-1013
- Group SIDs:
  - S-1-5-32-544 (Administrators)
  - S-1-5-32-545 (Users)
  - S-1-5-32-546 (Guests)
  - S-1-5-18 (Local System)
  - ...
- Privileges:
  - SeShutdownPrivilege
  - SeChangeNotifyPrivilege
  - SeUndockPrivilege
  - SeIncreaseWorkingSetPrivilege
  - SeTimeZonePrivilege
  - ...
- Owner SID: S-1-5-21-3623811015-3361044348-30300820-1013
- Primary Group SID: S-1-5-21-3623811015-3361044348-30300820-513
- Default DACL:
  - ACEs:
    - Allow: S-1-5-32-544 (Administrators)
    - Allow: S-1-5-32-545 (Users)
    - Deny: S-1-5-32-546 (Guests)
    - ...
- Source:
  - Source Name: User32
  - Source LUID: 0x3e7
- Impersonation Level: SecurityImpersonation
- Token Type: TokenPrimary
- Token ID: 0x1f4
- Authentication ID: 0x3e7
- Modified ID: 0x1f5
- Expiration Time: Infinite
```

Manipulating, accessing, and using security tokens is part and parcel for Windows malware. We will into more detail on this later on.

### Dllhost.exe

`dllhost.exe` stands for "Dynamic Link Library Host". We'll talk more about DLLs soon, but for now, just understand that a DLL is a file containing code that can be reused, but a DLL cannot be run as a standalone process, as a process must be an `exe`. `dllhost.exe` serves to enable a DLL to run like a process, which is why you will usually see multiple instances of `dllhost.exe` running. Each will host a different DLL or COM objects (more on COM later).

### NisSrv.exe

Stands for "Network Inspection Service". This process is part of the Windows Defender Firewall, performing traffic inspection and enforcing network security policies.

### Other Processes

I encourage you to go through the list and independently research what each process does. Some will be uninteresting to you, others can be deep rabbit holes worthy of their own papers and books.

## Binary and Library File Formats

I'm sure you've come across files with the extensions `.exe` and `.dll` many times before. Most people understand that `.exe`s are runnable applications, but `.dll`s are a little more fuzzy. Many nvoice pentesters and red teamers go quite a while without really understannding what a DLL is.

### Libraries

A DLL is a library file that contains code that can be re-used by other applications. A good way to think about library files is as *plugin modules*. They augment the functionality available to an EXE.

Say you have a function that implements a very complicated encryption algorithm. You pass in data and a password, and it outputs encrypted data. Say theres another function that decrypts the output from the function. Here's some pseudocode:

```
func encrypt(data, key) returns encrypted_bytes {
    # ... very complicated encryption logic here
}

func decrypt(data, key) returns decrypted_bytes {
    # ... very complicated decryption logic here
}
```

Without library files, you would have to copy and paste these large code blocks into every new EXE project. This quickly becomes unmanageable. Say you have several, or even dozens of EXE projects that rely on this code. You copy and paste it manually into every project's source files. 

One day, a security researcher investigatges your encryption algorithm and finds a serious security flaw. It is possible to recover the encrypted data without knowing the full encryption key. You need to update the code to fix the vulnerability.

Now you have the problem of going into every EXE project and updating the source code with the new version of the encryption functions. On top of being tedious and time consuming, it is very possible that you will make a mistake and miss one, leaving it vulnerable. If only you could write the code once, put it in a single seperate file that your EXEs could load, and only ever have to update this one version. Well, this is what libraries allow us to do

#### The Major Library Types

There are two types of libraries: static and dynamic.

Static libraries patch your library code into an executable project when it is compiled. The library code is merged into that single EXE. This provides the advantage of ensuring that your EXE will be able to load everywhere it is deployed. It does not need to search for the library as an external dependency.

Dynamic libraries are loaded after you start your EXE process. At some point in its execution, the EXE will ask the operating system to load the DLL into memory and make its code available for use. You might (rightly) wonder why you would use a dynamic library over a static library, since the DLL could be missing or corrupt. The reason these are used is because it makes it much easier to deploy new versions, efficiently use resources. Perhaps the most important benefit, however, is that multiple applications can use one DLL file. If the library would statically linked, every application using that library functionality would have redundant copies of the code. Aside from bloating file sizes, this can cause a nightmare in managing versions of the library code across multiple projects.

#### DLL Use Cases

DLLs are ubiquitous on modern Windows systems. Below are some of the many use cases:

- System components: Core system functionalities such as Windows Kernel components use DLLs.
- System services: Many services on the system will be implemented and loaded as DLLs. This simplifies and organizes management of the service.
- Applications: Use applications often have many dependencies, especially for functionalities like GUI elements and networking.
- Interoperability: System components like COM (Component Object Model) and ActiveX are often implemented as DLLs.

Every ordinary executable on the system will depend on one or more DLLs. Even the Windows kernel uses DLLs.


## Windows and NT APIs

You can do very little on a system without requesting operations from the OS. Reading & writing files, starting processes, creating threads, allocating memory, and many more actions are performed on *behalf* of the user by the OS. Fortunately, Microsoft has provided a very extensive set of *application programming interfaces* for us to use to perform these tasks. These APIs are just sets of libraries (DLLs) published by Microsoft that simplify and manage making requests to the OS for various tasks.

Lets take the example of writing a file. From the GUI, this can be as simple as right clicking in the file explorer, selecting "new", and clicking the desired file type. But how does file explorer actually create the new file?

Remember that the OS is ultimately responsible for allowing user processes (like file explorer) to read, write, create, and delete files. Recall from [part 1](/posts/2024-5-16-malware-development-1/#user-mode-versus-kernel-mode) how the system is divided between user-mode and kernel-mode. Every time the OS needs to do something on behalf of the user, a transition is made between user-mode and kernel-mode. It does this through what we call *system calls*. We will talk more about these later.

### The Windows API

One of the most common APIs that applications use -- and of significant interest to us -- is the Windows API. The Windows API is implemented in a set of DLLs that are by default loaded into user-mode processes. It is the primary interface for developing Windows applications. Functions exposed to developers in Windows API DLLs include procedures for file input/output, inter-process communication, memory allocation, and more.

### The NT API

The Windows API itself does not make the system calls that are used to broker access to system resources. This is done by the NT API. The Windows API forwards to the NT API to actually make the transition into kernel-mode. For example, calling the `WriteFile` Windows API will result in the following chain of events:

```
+-------------------------------------------+
|           User-mode Application           |
+-------------------------------------------+
                    |
                    | Calls WriteFile
                    v
+-------------------------------------------+
|              Kernel32.dll                 |
|  (WinAPI implementation of WriteFile)     |
+-------------------------------------------+
                    |
                    | Calls NtWriteFile
                    v
+-------------------------------------------+
|                Ntdll.dll                  |
| (Transition layer to NTAPI functions)     |
+-------------------------------------------+
                    |
                    | Calls NtWriteFile
                    v
+-------------------------------------------+
|                NTOSKRNL.exe               |
|          (Kernel-mode execution)          |
+-------------------------------------------+
                    |
                    | Performs actual I/O operations
                    v
+-------------------------------------------+
|         Filesystem Driver (e.g., NTFS)    |
|   (Handles file system-specific details)  |
+-------------------------------------------+
                    |
                    | Writes data to disk
                    v
+-------------------------------------------+
|                Physical Disk              |
| (Hardware where data is stored)           |
+-------------------------------------------+
```

As you can see, several very complex operations happen after the user-mode/kernel-mode transition happens. As the developer in the user-mode world, we don't really think about all these messy details. Later on, we will dive into using direct system calls, as they offer us many possibilities as malware developers.

The actual machine code instruction that triggers the transition to kernel mode is the `syscall` instruction (`0f 05` in hex). When the CPU hits this instruction and executes it, a series of events unfolds:

1. CPU encounters `syscall` instruction protected mode (user-mode)
2. CPU saves current state of the execution context (e.g., registers)
3. CPU loads address of code to execute in kernel-mode (in this case, the kernel's handler code for system calls)
4. CPU changes privilege level to real mode
5. Kernel receives execution at its system call handler
6. Kernel looks up system call number and reads parameters passed from user-mode
7. Kernel matches system call number with appropriate kernel-mode function that implements the desired action (like writing the file)
8. Kernel executes the function and jumps to code to return to user-mode
9. CPU restores saved context
10. CPU changes privilege level back to protected mode

### Examples of Windows APIs

Below are some examples of Win32 API functions, which are part of the Windows API used for creating and managing Windows applications:

Here are some examples of Win32 API functions:

### File Management Functions
- `CreateFile`: Creates or opens a file or I/O device.
- `ReadFile`: Reads data from a file or I/O device.
- `WriteFile`: Writes data to a file or I/O device.
- `CloseHandle`: Closes an open object handle.

### Process and Thread Functions
- `CreateProcess`: Creates a new process and its primary thread.
- `ExitProcess`: Ends the calling process and all its threads.
- `CreateThread`: Creates a new thread in the calling process.
- `TerminateThread`: Terminates a thread.

### Window Management Functions
- `CreateWindowEx`: Creates an overlapped, pop-up, or child window with an extended window style.
- `ShowWindow`: Sets the specified window's show state.
- `DestroyWindow`: Destroys the specified window.
- `UpdateWindow`: Updates the client area of the specified window by sending a `WM_PAINT` message.

### GDI (Graphics Device Interface) Functions
- `CreateDC`: Creates a device context for a device.
- `DeleteDC`: Deletes the specified device context.
- `BitBlt`: Performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.
- `TextOut`: Writes a character string at the specified location, using the currently selected font, background color, and text color.

### Registry Functions
- `RegOpenKeyEx`: Opens the specified registry key.
- `RegSetValueEx`: Sets the data for the specified value in a registry key.
- `RegGetValue`: Retrieves the type and data for the specified registry value.
- `RegCloseKey`: Closes a handle to the specified registry key.

### Memory Management Functions
- `VirtualAlloc`: Reserves or commits a region of pages in the virtual address space of the calling process.
- `VirtualFree`: Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling process.
- `HeapCreate`: Creates a private heap object that can be used by the calling process.
- `HeapAlloc`: Allocates a block of memory from a heap.

#### Synchronization Functions
- `CreateMutex`: Creates or opens a named or unnamed mutex object.
- `WaitForSingleObject`: Waits until the specified object is in the signaled state or the time-out interval elapses.
- `ReleaseMutex`: Releases ownership of the specified mutex object.
- `CreateEvent`: Creates or opens a named or unnamed event object.


### Examples of NT APIs

#### Process and Thread Management
- `NtCreateProcess`: Creates a new process object.
- `NtCreateThread`: Creates a new thread within a process.
- `NtTerminateProcess`: Terminates the specified process and all of its threads.
- `NtTerminateThread`: Terminates a specified thread.

#### Memory Management
- `NtAllocateVirtualMemory`: Allocates virtual memory within the specified process.
- `NtFreeVirtualMemory`: Releases, decommits, or both, a region of pages within the virtual address space of a specified process.
- `NtProtectVirtualMemory`: Changes the protection on a region of committed pages in the virtual address space of a specified process.
- `NtReadVirtualMemory`: Reads virtual memory in a specified process.
- `NtWriteVirtualMemory`: Writes to virtual memory in a specified process.

#### File System
- `NtCreateFile`: Creates or opens a file or I/O device.
- `NtReadFile`: Reads data from a file or I/O device.
- `NtWriteFile`: Writes data to a file or I/O device.
- `NtClose`: Closes an object handle.

#### Registry
- `NtCreateKey`: Creates a registry key.
- `NtDeleteKey`: Deletes a registry key.
- `NtOpenKey`: Opens a registry key.
- `NtQueryValueKey`: Retrieves the value of a registry key.
- `NtSetValueKey`: Sets the value of a registry key.

#### Security and Access Control
- `NtOpenProcessToken`: Opens the access token associated with a process.
- `NtDuplicateToken`: Duplicates an existing token.
- `NtAdjustPrivilegesToken`: Enables or disables privileges in an access token.
- `NtQueryInformationToken`: Retrieves a specified type of information about an access token.

#### Synchronization
- `NtCreateSemaphore`: Creates a semaphore object.
- `NtReleaseSemaphore`: Increases the count of the specified semaphore object.
- `NtWaitForSingleObject`: Waits until the specified object is in the signaled state or the time-out interval elapses.
- `NtSignalAndWaitForSingleObject`: Signals an object and waits for a specified object to enter the signaled state.

#### Miscellaneous
- `NtQuerySystemInformation`: Retrieves various kinds of system information.
- `NtSetSystemInformation`: Sets various kinds of system information.
- `NtQueryPerformanceCounter`: Retrieves the current value of the performance counter and the counter's frequency.


### Rtl APIs (Runtime Library APIs)

The DLL implementing the NT APIs also implements a series of higher level functions dubbed the RTL API:

#### String Manipulation
- `RtlCopyUnicodeString`: Copies one Unicode string to another.
- `RtlCompareUnicodeString`: Compares two Unicode strings.
- `RtlInitUnicodeString`: Initializes a Unicode string.

#### Memory Management
- `RtlAllocateHeap`: Allocates a block of memory from a heap.
- `RtlFreeHeap`: Frees a block of memory allocated from a heap.
- `RtlZeroMemory`: Fills a block of memory with zeros.
- `RtlCopyMemory`: Copies bytes from one buffer to another.

#### Time and Date
- `RtlTimeToTimeFields`: Converts a system time to time fields (year, month, day, etc.).
- `RtlTimeFieldsToTime`: Converts time fields to system time.
- `RtlLocalTimeToSystemTime`: Converts local time to system time.

#### Exception Handling
- `RtlRaiseException`: Raises an exception.
- `RtlCaptureContext`: Captures the current context (register values).
- `RtlRestoreContext`: Restores a context (register values).

#### Synchronization
- `RtlInitializeCriticalSection`: Initializes a critical section object.
- `RtlEnterCriticalSection`: Enters a critical section.
- `RtlLeaveCriticalSection`: Leaves a critical section.
- `RtlDeleteCriticalSection`: Deletes a critical section object.

See the next entry [here](/posts/2024-5-17-malware-development-3/)