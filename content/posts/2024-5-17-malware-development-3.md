+++
title = "Red Teamer's Guide to Malware Development 3"
date = 2024-05-17T11:14:54-05:00
draft = false
+++

> This is a guide for malware development for ethical red teaming. Nowadays, there are lots of paid courses that cover these same concepts, but fortunately for everyone, these not necessary to get up to speed. Most of the techniques these courses cover are open source.


The following topics will be covered in this entry:

- The PE file structure
- Parsing a PE



## What Are File Formats?

We've already talked about EXEs and DLLs in [Part 2](/posts/2024-5-17-malware-development-2/). This entry dives into the *file format* that these files use -- the PE or Portable Executable file format.

A file format is a standard way of encoding information for storage in a computer file. It specifies how data is stored, organized, and manipulated. Different file types can be more or less structured. A (nearly) completely unstructured file type would be a text file. On the other end, file formats like PE are much more rigid and well defined.

A file format can be thought of as a data structure. In C, you might see a data structure like this:

```C
struct Person {
    char    firstName[12];
    int     age;
    float   height;
};
```

Each field will take up a certain size and the bytes of any given instance of that struct would reflect that. 

```
Byte Offset  | Field
-------------|--------------
     0       | firstName[0]
     1       | firstName[1]
     2       | firstName[2]
     3       | firstName[3]
     4       | firstName[4]
     5       | firstName[5]
     6       | firstName[6]
     7       | firstName[7]
     8       | firstName[8]
     9       | firstName[9]
    10       | firstName[10]
    11       | firstName[11]
    12       | age (byte 0)
    13       | age (byte 1)
    14       | age (byte 2)
    15       | age (byte 3)
    16       | height (byte 0)
    17       | height (byte 1)
    18       | height (byte 2)
    19       | height (byte 3)
```

A structured file format might look similar. Suppose we make a structured file format. An example for our save game format would be:

- Magic bytes: These are the same value for every valid instance of our custom file format.
- Timestamp
- Player data: Information about this particular save, e.g.,
  - Current player level
  - Current player health
  - Player inventory
  - Position coordinates
- Quest data:
  - Quest number
  - Quest name
  - Completion status

In code, we can represent this as the following:

```C++
#define MAGIC_BYTES 0xDEADBEEF
#define MAX_PLAYER_NAME_LENGTH 32
#define MAX_INVENTORY_ITEMS 100
#define SPRITE_SIZE 1024

typedef struct {
    char itemName[32];
    int quantity;
} InventoryItem;

typedef struct {
    uint32_t magicBytes;        // Magic bytes to identify the file format
    int64_t timestamp;          // Unix timestamp of when the save was created
    int level;                  // Current player level
    float health;               // Current player health
    InventoryItem inventory[MAX_INVENTORY_ITEMS];  // Player inventory
    float positionX;            // Position coordinates
    float positionY;
    float positionZ;
    int questID;                // Which quest we're on
    char questName[64];         // Name of the current quest
    int isCompleted;            // Whether the quest is completed or not
    unsigned char sprite[1024]; // Binary RGB data of the character's sprite / image
} SaveGame;
```

We can visualize it like this:

```
Byte Offset  | Size (bytes) | Field
-------------|--------------|------------------------------
     0       |      4       | magicBytes
     4       |      8       | timestamp
    12       |      4       | level
    16       |      4       | health
    20       |   3600       | inventory (32 bytes * 100 items)
   3620      |      4       | positionX
   3624      |      4       | positionY
   3628      |      4       | positionZ
   3632      |      4       | questID
   3636      |     64       | questName
   3700      |      4       | isCompleted
   3704      |   1024       | sprite
```

When our game loads the save file, it will first check the magic bytes. If they match `0xDEADBEEF`, the loading will continue, otherwise the game will report the save is corrupted. From here, the game will proceed to enter the game world at the appropriate level, with the character of the given name at the previous coordinates, and with the saved inventory and stats.

## The PE File Format

Windows binaries -- EXEs and DLLs, file that are in the PE file format -- are represented the same way, although they are a bit more complex. Fundamentally, however, they are still just a data structure comprised of headers with data about the program and sections with the binary code.

Just like our game example, the PE format starts with magic bytes. The magic bytes are followed by headers containing data about the program. Some of these headers contain data about the code, so that the OS's program loader (the Windows loader) knows how to load the code and data into memory and where to start the program.

The format begins with the DOS header, which is a vestigial structure from the days of MS DOS. The orginal format of EXE file was the "DOS MZ Executable" format. The binaries looked like this:

```
+----------------------+---------------------------------------------+
| Offset               | Description                                 |
+----------------------+---------------------------------------------+
| 0x0000               | DOS Header (IMAGE_DOS_HEADER)               |
|                      |  e_magic (signature, "MZ")                  |
|                      |  e_cblp (Bytes on last page of file)        |
|                      |  e_cp (Pages in file)                       |
|                      |  e_crlc (Relocations)                       |
|                      |  e_cparhdr (Size of header in paragraphs)   |
|                      |  ...                                        |
|                      |  e_lfarlc (File address of relocation table)|
|                      |  e_lfanew (Not used in DOS MZ, reserved)    |
+----------------------+---------------------------------------------+
| After Header         | Relocation Table (if any)                   |
+----------------------+---------------------------------------------+
| After Reloc Table    | Code and Data                               |
+----------------------+---------------------------------------------+
```

When Microsoft revamped their operating system with Windows NT, the file format needed to change to accomodate the new improvements. Thus the PE structure was adopted. For compatibility purposes, the orginal DOS headers were left, but new headers and sections were added. Now, the DOS header hold the address (really the offset) of the new PE headers. The new format looks like this in the tool PE-Bear:

![PE File Format Headers](/pe-headers.png)

The lines marked with the paper icon are headers. The DOS stub has the icon of the terminal, indicating that it is just a standalone code region. The sections are given puzzle piece icons. 

We've already talked about headers. Now we turn to the sections. The purpose of the section is simple: hold code and data.

As you come across different EXEs and DLLs, you'll see that many of the sections share similar (or the same) names. This is because there is a nomenclature for the names of basic sections that appear frequently in PEs. The names reflect the purpose of the section. Here is an overview of some of the most common section names and their purposes:

- `.text`: Contains the executable code of the program. You might expect (and indeed sometimes see) "`.code`" instead. The name "text" is vestigial from conventions used in the early days of UNIX, where assembly code was commonly reffered to as "text". "Text" became synonymous with "code".
- `.rdata`: Read only data, like constant values and strings of characters that should not be modified at runtime.
- `.data`: Initialized global and static variables that may be modified during execution.
- `.pdata`: Contains information for exception handling, specifically for structured exception handling (SEH) in Windows.
- `.rsrc`: Contains application resources, such as icons, menus, dialog boxes, string tables, and other user-interface elements.
- `.reloc`: Contains relocation information used to adjust addresses in the code and data sections when the executable is loaded into memory at a different base address than the one it was linked with.

## NT Headers

The main three headers added when the PE file format was adopted were the NT headers. There are three headers contained in the NT headers:

- Signature
- File header
- Optional header (very much not optional for EXEs and DLLs)

The signature is a magic byte string that declares the file format as a PE file. The File header contains metadata about the file, such as target machine, number of sections, timestamps, and characteristics about the file. The confusingly named "Optional" header contains all-important information about loading the executable in memory and beginning execution. Each section then has a header with its own information.

```C++
// WORD: 16 bit number
// DWORD: 32 bit number
// LONG: 32 bit number
// LONGLONG: 64 bit number
// ULONG/ULONGLONG: Unsigned long or unsigned long long

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;                      // "PE\0\0" signature, identifies the file as a PE file
    IMAGE_FILE_HEADER FileHeader;         // File header containing general information about the file
    IMAGE_OPTIONAL_HEADER OptionalHeader; // Optional header containing additional information needed to load the executable
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;                      // Target machine type (e.g., x86, x64)
    WORD    NumberOfSections;             // Number of sections in the file
    DWORD   TimeDateStamp;                // Timestamp of file creation (UNIX timestamp)
    DWORD   PointerToSymbolTable;         // Pointer to the symbol table (deprecated)
    DWORD   NumberOfSymbols;              // Number of symbols in the symbol table (deprecated)
    WORD    SizeOfOptionalHeader;         // Size of the optional header
    WORD    Characteristics;              // Attributes of the file (e.g., executable, DLL)
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;                    // Identifies the format (PE32+ for 64-bit, value 0x20B)
    BYTE        MajorLinkerVersion;       // Major version number of the linker
    BYTE        MinorLinkerVersion;       // Minor version number of the linker
    DWORD       SizeOfCode;               // Size of the code (text) section
    DWORD       SizeOfInitializedData;    // Size of the initialized data section
    DWORD       SizeOfUninitializedData;  // Size of the uninitialized data section (BSS)
    DWORD       AddressOfEntryPoint;      // Address of the entry point relative to the image base
    DWORD       BaseOfCode;               // Base address of the code section relative to the image base
    ULONGLONG   ImageBase;                // Preferred address of the first byte of the image when loaded into memory
    DWORD       SectionAlignment;         // Alignment of sections in memory
    DWORD       FileAlignment;            // Alignment of raw data in the file
    WORD        MajorOperatingSystemVersion; // Major version number of the required operating system
    WORD        MinorOperatingSystemVersion; // Minor version number of the required operating system
    WORD        MajorImageVersion;        // Major version number of the image
    WORD        MinorImageVersion;        // Minor version number of the image
    WORD        MajorSubsystemVersion;    // Major version number of the subsystem
    WORD        MinorSubsystemVersion;    // Minor version number of the subsystem
    DWORD       Win32VersionValue;        // Reserved, must be zero
    DWORD       SizeOfImage;              // Total size of the image when loaded into memory, including all headers and sections
    DWORD       SizeOfHeaders;            // Combined size of all headers
    DWORD       CheckSum;                 // Checksum of the image, used by the loader
    WORD        Subsystem;                // Subsystem required to run this image (e.g., Windows GUI, Windows CUI)
    WORD        DllCharacteristics;       // DLL characteristics (e.g., dynamic base, NX compatible)
    ULONGLONG   SizeOfStackReserve;       // Size of the stack to reserve
    ULONGLONG   SizeOfStackCommit;        // Size of the stack to commit
    ULONGLONG   SizeOfHeapReserve;        // Size of the heap to reserve
    ULONGLONG   SizeOfHeapCommit;         // Size of the heap to commit
    DWORD       LoaderFlags;              // Reserved, must be zero
    DWORD       NumberOfRvaAndSizes;      // Number of data-directory entries in the remainder of the optional header
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // Array of data directory entries
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];       // An 8-byte, null-padded string. If the string is exactly 8 characters long, there is no terminating null.
    union {
            DWORD   PhysicalAddress;             // For object files, physical address.
            DWORD   VirtualSize;                 // For image files, total size of the section when loaded into memory.
    } Misc;
    DWORD   VirtualAddress;                      // The address of the first byte of the section when loaded into memory, relative to the image base.
    DWORD   SizeOfRawData;                       // The size of the initialized data on disk, in bytes. Must be a multiple of FileAlignment.
    DWORD   PointerToRawData;                    // A file pointer to the first page of the section within the COFF file. Must be a multiple of FileAlignment.
    DWORD   PointerToRelocations;                // A file pointer to the beginning of the relocation entries for the section (COFF object files only).
    DWORD   PointerToLinenumbers;                // A file pointer to the beginning of the line-number entries for the section (COFF object files only).
    WORD    NumberOfRelocations;                 // The number of relocation entries for the section (COFF object files only).
    WORD    NumberOfLinenumbers;                 // The number of line-number entries for the section (COFF object files only).
    DWORD   Characteristics;                     // Flags that describe the characteristics of the section.
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

```

I recommend you take some time to carefully go through each field and read the comment. If the purpose of a field is unclear, look it up and read more.

## Relative vs. Absolute Addresses

When files describe themselves -- such as a PE file holding the address of the first instruction to execute when the program is loaded -- there is uncertainty about the actual memory address (in virtual or physical memory) that the different described components are located. For this reason, most addresses are stored as offsets from the base of the file, also known as *relative virtual addresses*. 

For example, one EXE might have an `OptionalHeader->AddressOfEntryPoint` value of `0x224c`. From earlier sections, we discussed virtual memory, and `0x224c` does not look like any of the example virtual addresses. This is because it is an offset, not an address in virtual memory.

Specifically, it is an offset from the base of the loaded image in memory. Suppose that the EXE is loaded in memory at virtual address (VA) 0x00007FF627B20000. When the loader goes to hand execution to the program's main code, it will look up the `OptionalHeader->AddressOfEntryPoint` value (0x224c) and add it to the loaded base address, and then start executing the main program at that address. Thus the offset (RVA) is converted to the final address in virtual memory (VA).

## Optional Header in Depth

Lets walk through some of the most important fields of the Optional header:

- `AddressOfEntryPoint`: This 4 byte field indicates where the EXE will begin executing once the Windows image loader completes its work loading the EXE into memory.
- `ImageBase`: The address where the image would preferr to be loaded in memory. This is essentially ignored in files with ASLR disabled. When ASLR is enabled, a randomized base address will be chosen. ASLR is set in the `OptionalHeader->DllCharacteristics` field, which is a two byte field which can hold the flag `IMAGE_DLLCHARACTERISTICS_DYNAMICBASE`. This will instruct the loader to use ASLR for the process.
- `SizeOfCode`, `BaseOfCode`: Indicate the total size of all code sections and the beginning address of code data relative to the image base.

### DLL Characteristics Field

Mentioned briefly above, the `DllCharacteristics` field is one of the most important fields in the header. It contains various flags indicating the behavior of the PE file. This might make the name somewhat confusing, as the characteristics apply to the current file, regardless of whether it is an EXE or DLL. Some of the more important flags are the following:

- `IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE`: Covered previously.
- `IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY`: Instructs the OS to check the integrity of the PE file before loading.
- `IMAGE_DLLCHARACTERISTICS_NX_COMPAT`: Instructs the OS to enable Data Execution Prevention (DEP), which is a security feature which prevents data on the stack from being executed like code. This mitigates some traditional stack overflow exploits.
- `IMAGE_DLLCHARACTERISTICS_NO_SEH`: Disables the use of Structured Exception Handling (SEH).
- `IMAGE_DLLCHARACTERISTICS_WDM_DRIVER:` Indicates the file is a Windows Driver Model (WDM) driver, a type of kernel-mode driver.

### Data Directories

At the end of the optional header is a table of zero or more (up to 16) data directories. The table stores the RVA the each actual data directory and its size:

```
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
```

The actual data directory (not the entry for it in the table) will be located inside one of the PE's sections. Data directories have different purposes, from declaring exported functions (in the case of DLLs) to certificate and copyright information. Some important data directories are below:

- **Import Address Table (IAT):** Contains the addresses of functions imported from DLLs, used at runtime to resolve the addresses of these functions.
- **Export Address Table (EAT):** Contains addresses of functions exported by this DLL for consumption in other EXEs and DLLs.
- **Base Relocation Table:** Used to adjust addresses in the PE when the PE is loaded into memory at different addresses from the preferred base (see `OptionalHeader->ImageBase`).
- **Resource:** Miscellaneous data blobs, ordinarily like icons, bitmaps, and strings. Sometimes used by packers for holding packed data.

With only some exceptions, each DD will correspond with a section, e.g.,:

- IAT: `.idata`
- EAT: `.edata`
- Relocation Table: `.reloc`
- Resource: `.rsrc`

### Section Headers

Remember that all code and data needed by the code are retained in sections. After the NT headers, there is a table of section headers. The headers contain data about each section:

```C++
typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];    // An 8-byte array containing the name of the section.
    union {
            DWORD   PhysicalAddress;          // Physical address (not used in PE files).
            DWORD   VirtualSize;              // Virtual size of the section when loaded into memory.
    } Misc;
    DWORD   VirtualAddress;                   // The RVA (Relative Virtual Address) of the section.
    DWORD   SizeOfRawData;                    // Size of the section in the PE file.
    DWORD   PointerToRawData;                 // File pointer to the first page within the COFF file.
    DWORD   PointerToRelocations;             // File pointer to the beginning of the relocation entries for the section.
    DWORD   PointerToLinenumbers;             // File pointer to the beginning of the line-number entries for the section.
    WORD    NumberOfRelocations;              // Number of relocation entries for the section.
    WORD    NumberOfLinenumbers;              // Number of line-number entries for the section.
    DWORD   Characteristics;                  // Flags describing characteristics of the section.
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

The Windows image loader needs this information when loading the executable into memory. On a first look, it might seem like there are redundant fields. Wouldn't the virtual address and pointer to raw data be the same thing? In reality, no. The address that the section that is loaded into memory at (relative to the image base) is actually different than the offset of the section in the PE file. `VirtualAddress` refers to this runtime load location. `PointerToRawData` refers to the offset from the base of the file. The reasons for this are simple but not relevant for the purposes of this article.

After the section header (and its padding), the actual sections will begin. 

## Generating a PE From Scratch

While linkers, assemblers, etc. typically handle generation of our PE files from source code, it is of course possible to generate one from scratch, from raw bytes. We need four key ingredients to do this successfully:

- Required headers
- Required header values
- Required alignment & padding
- Correct byte ordering (little endian)

Of these, the last is the hardest to get correct. The Windows image loader requires that, following the NT headers, all remaining headers and sections are aligned according to `OptionalHeader->File Alignment`.

### PE Generation With Pure Byte Manipulation

The following code demonstrates generation of a valid PE file straight from bytes. It demonstrates clearly offsets, byte ordering, and needed values. I encourage you to try to compile and run this code yourself using Visual Studio or another C++ toolchain, and then execute the output binary in [x64Dbg](https://x64dbg.com/) or view it in [PE Bear](https://github.com/hasherezade/pe-bear).

```C++
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdint>

// Helper functions to write data to a file in little-endian format
void writeUInt8(std::ofstream& out, uint8_t value) {
    out.put(value);
}

void writeUInt16(std::ofstream& out, uint16_t value) {
    out.put(value & 0xFF);
    out.put((value >> 8) & 0xFF);
}

void writeUInt32(std::ofstream& out, uint32_t value) {
    out.put(value & 0xFF);
    out.put((value >> 8) & 0xFF);
    out.put((value >> 16) & 0xFF);
    out.put((value >> 24) & 0xFF);
}

void writeUInt64(std::ofstream& out, uint64_t value) {
    out.put(value & 0xFF);
    out.put((value >> 8) & 0xFF);
    out.put((value >> 16) & 0xFF);
    out.put((value >> 24) & 0xFF);
    out.put((value >> 32) & 0xFF);
    out.put((value >> 40) & 0xFF);
    out.put((value >> 48) & 0xFF);
    out.put((value >> 56) & 0xFF);
}

void writePeBytes() {
    std::ofstream outFile("output.exe", std::ios::binary);

    if (!outFile) {
        std::cerr << "Failed to open output file." << std::endl;
        return;
    }

    // MS-DOS Stub
    outFile.write("MZ", 2);                       // e_magic
    outFile.seekp(0x3C);                          // e_lfanew
    writeUInt32(outFile, 0x80);                   // PE header offset

    // Padding to PE header
    outFile.seekp(0x80);

    // PE Header
    outFile.write("PE\0\0", 4);                   // Signature
    writeUInt16(outFile, 0x8664);                 // Machine (AMD64)
    writeUInt16(outFile, 1);                      // NumberOfSections
    writeUInt32(outFile, 0);                      // TimeDateStamp
    writeUInt32(outFile, 0);                      // PointerToSymbolTable
    writeUInt32(outFile, 0);                      // NumberOfSymbols
    writeUInt16(outFile, 0xF0);                   // SizeOfOptionalHeader
    writeUInt16(outFile, 0x22);                   // Characteristics

    // Optional Header (Standard Fields)
    writeUInt16(outFile, 0x20B);                  // Magic (PE32+)
    writeUInt8(outFile, 0x00);                    // MajorLinkerVersion
    writeUInt8(outFile, 0x00);                    // MinorLinkerVersion
    writeUInt32(outFile, 0x200);                  // SizeOfCode
    writeUInt32(outFile, 0x200);                  // SizeOfInitializedData
    writeUInt32(outFile, 0);                      // SizeOfUninitializedData
    writeUInt32(outFile, 0x1000);                 // AddressOfEntryPoint
    writeUInt32(outFile, 0x1000);                 // BaseOfCode
    writeUInt64(outFile, 0x400000);               // ImageBase
    writeUInt32(outFile, 0x1000);                 // SectionAlignment
    writeUInt32(outFile, 0x200);                  // FileAlignment
    writeUInt16(outFile, 0x4);                    // MajorOperatingSystemVersion
    writeUInt16(outFile, 0);                      // MinorOperatingSystemVersion
    writeUInt16(outFile, 0);                      // MajorImageVersion
    writeUInt16(outFile, 0);                      // MinorImageVersion
    writeUInt16(outFile, 0x4);                    // MajorSubsystemVersion
    writeUInt16(outFile, 0);                      // MinorSubsystemVersion
    writeUInt32(outFile, 0);                      // Win32VersionValue
    writeUInt32(outFile, 0x2000);                 // SizeOfImage
    writeUInt32(outFile, 0x200);                  // SizeOfHeaders
    writeUInt32(outFile, 0);                      // CheckSum
    writeUInt16(outFile, 0x3);                    // Subsystem (Windows CUI)
    writeUInt16(outFile, 0);                      // DllCharacteristics
    writeUInt64(outFile, 0x100000);               // SizeOfStackReserve
    writeUInt64(outFile, 0x1000);                 // SizeOfStackCommit
    writeUInt64(outFile, 0x100000);               // SizeOfHeapReserve
    writeUInt64(outFile, 0x1000);                 // SizeOfHeapCommit
    writeUInt32(outFile, 0);                      // LoaderFlags
    writeUInt32(outFile, 16);                     // NumberOfRvaAndSizes

    // Data Directories (16 entries, all zeros)
    for (int i = 0; i < 16; ++i) {
        writeUInt64(outFile, 0);
    }

    // Section Header
    outFile.write(".text", 8);                    // Name
    writeUInt32(outFile, 0x200);                  // VirtualSize
    writeUInt32(outFile, 0x1000);                 // VirtualAddress
    writeUInt32(outFile, 0x200);                  // SizeOfRawData
    writeUInt32(outFile, 0x200);                  // PointerToRawData
    writeUInt32(outFile, 0);                      // PointerToRelocations
    writeUInt32(outFile, 0);                      // PointerToLinenumbers
    writeUInt16(outFile, 0);                      // NumberOfRelocations
    writeUInt16(outFile, 0);                      // NumberOfLinenumbers
    writeUInt32(outFile, 0x60000020);             // Characteristics

    // .text Section Data (Minimal executable code)
    outFile.seekp(0x200);
    uint8_t code[] = {
        0x48, 0x31, 0xC0,         // xor rax, rax
        0xC3                      // ret
    };
    outFile.write(reinterpret_cast<char*>(code), sizeof(code));

    // Ensure the file is padded to the correct size
    outFile.seekp(0x400 - 1);
    outFile.write("", 1);

    outFile.close();

    std::cout << "PE file 'output.exe' generated successfully." << std::endl;
}

int main() {
    writePeBytes();

    return 0;
}

```


## References

- Windows Internals 7th Ed. Part 1
- [PE Bear](https://github.com/hasherezade/pe-bear)
- [X64Dbg](https://x64dbg.com/)